# 1：【mybatis】在mybatis逆向工程生成类型的时候 出现 .java.1等等 说明其他数据库有一样的表名 要在 jdbcCoonection加以下的

```xml
<property name="nullCatalogMeansCurrent" value="true"/> 
```

列如

```xml
 <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"                    connectionURL="jdbc:mysql://localhost:3306/ssm?
serverTimezone=UTC"
                        userId="root"
                        password="123456yql">
            <property name="nullCatalogMeansCurrent" value="true"/>
</jdbcConnection>
```

# 2：【mysql】数据库的表数据删除后 解决自增问题

```sql
SET @auto_id = 0;
UPDATE t_emp
SET emp_id = (@auto_id := @auto_id + 1);
ALTER TABLE t_emp
    AUTO_INCREMENT = 1;
```

# 3.【Mybatis】数据封装时数据库表字段和POJO中实体类属性命名不一致的几种解决方案

## 解决方案一：命名一致

我们可以把POJO中的实体类命名和数据库表中字段的命名调整一致，但是数据库表字段的命名方式并不是驼峰式命名方式，不符合Java中对于类属性的命名规则，因此不推荐使用。

![img](https://yqlyq.github.io/problemImages/imgs202306072105866.png)

![img](https://img-blog.csdnimg.cn/20200707155442321.png)

## 解决方案二：给表中字段取别名

我们可以通过在表对应的mapper.xml配置文件中**通过<sql>标签**给字段取别名的方式，使得重新命名的表字段别名与实体类中的属性名保持一致，再通过**<include>**标签引入sql代码块，这样也可以达到数据正常封装的效果。

```xml
<!--    通过<sql>标签给数据库表中字段取别名，设置id属性-->
    <sql id="columns">
        p_id as pid,
        p_name as pname,
        pg_id as pgid
    </sql>
<!--    再通过<include>标签引入sql代码块-->    
<select id="queryProduct" resultType="product1">
    select <include refid="columns"/> from product where ${column} = #{value}
</select>
```

以下是通过在mybatis配置文件中加入<setting>中的logImpl设置为STDOUT_LOGGING是为了使日志输出mybatis生产的sql语句，这样就可以通过日志输出看到在list中拿到了正常封装的数据对象。

```xml
<settings>
    <setting name="logImpl" value="STDOUT_LOGGING"/>
</settings>
```

## 解决方案三：通过resultMap来调整字段名与属性名映射一致

我们可以通过<resultMap>标签来将数据库表中字段映射到对应的实体类属性上，完成数据库查询数据的封装，如果实体类的属性中存在自定义类属性，那么也可以通过resultMap进行数据的层层映射，封装到对应自定义类中的基本类型数据中。

```xml
<resultMap id="productName" type="product1">
    <id property="pid" column="p_id"/>
    <result property="pname" column="p_name"/>
    <result property="pgid" column="pg_id"/>
</resultMap>
<select id="selectProductById" parameterType="int" resultMap="productName">
    select * from product where p_id = #{id}
</select>
```
## 解决方案四：使用Mybatis特殊设置

在Mybatis核心配置文件<settings>标签内设置mapUnderscoreToCamelCase属性的值为true，那么数据库就会将表字段的分割式命名(例如：p_id)自动映射到实体类的驼峰式命名(例如：pId)上，且不区分驼峰式命名的大小写。

```xml
<settings>
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

# 4.[Tomcat] 虚拟机配置 -Dfile.encoding=UTF-8

# 5.[idea] tomcat配置 On ‘Update‘ action 只有两个

IDEA 无法热加载自动更新，On ‘update’ action:选项里面没有update classes and resources这一选项
1.出现的问题

<img src="https://yqlyq.github.io/problemImages/imgs202306072106976.png">

2.原因: 在Tomcat Deployment选项部署项目选择了只有War包的项目

<img src="https://yqlyq.github.io/problemImages/imgs202306072106463.png">

3. 解决方法：在Tomcat 的 Deployment选项部署项目选择War exploded的项目

  <img src="https://yqlyq.github.io/problemImages/imgs202306072106590.png">

3. 重启Idea后效果
<img src="https://yqlyq.github.io/problemImages/imgs202306072106335.png">

# 6.【boostrap】glyphicons-halflings-regular.eot 加载不出来



如果 glyphicons-halflings-regular.eot 加载不出来 就是登录界面图标没出来 看看F12 网络他的请求地址对不对，不对的去改bootstrap/css/bootstrap.css.map  搜索 Glyphicons Halflings 换成这个 (改成自己的路径)

```css
@font-face {
  font-family: 'Glyphicons Halflings';
  src: url('../fonts/glyphicons-halflings-regular.eot');
  src: url('../fonts/glyphicons-halflings-regular.eot?#iefix') format('embedded-opentype'), url('../fonts/glyphicons-halflings-regular.woff2') format('woff2'), url('../fonts/glyphicons-halflings-regular.woff') format('woff'), url('../fonts/glyphicons-halflings-regular.ttf') format('truetype'), url('../fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular') format('svg');
}
```

# 7.【mysql】创建存储过程 来插入数据

```sql
DELIMITER //
CREATE PROCEDURE insert_data(IN max_num INT)
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0;
REPEAT
SET i = i + 1;
insert into my_table(login_acct, user_pswd, user_name, email) values (CONCAT('asd', i),CONCAT('asd', i),CONCAT('asd', i),CONCAT('asd', i));
UNTIL i = max_num
END REPEAT;
COMMIT;
END
```



# 8.[Thyemeleaf]  分页

在 Thymeleaf 中，您可以使用条件语句来根据当前页码的位置显示不同数量的分页链接。例如，如果您有一个名为 `currentPage` 的变量，它表示当前页码，以及一个名为 `totalPages` 的变量，它表示总页数，则可以这样做：

```html
<ul>
    <li th:if="${currentPage == 1}">
        <span th:each="page : ${#numbers.sequence(1, 3)}">
            <a th:href="@{/search(page=${page})}" th:text="${page}">Page</a>
        </span>
    </li>
    <li th:if="${currentPage > 1 and currentPage < totalPages}">
        <span th:each="page : ${#numbers.sequence(currentPage - 2, currentPage + 2)}">
            <a th:href="@{/search(page=${page})}" th:text="${page}">Page</a>
        </span>
    </li>
    <li th:if="${currentPage == totalPages}">
        <span th:each="page : ${#numbers.sequence(totalPages - 2, totalPages)}">
            <a th:href="@{/search(page=${page})}" th:text="${page}">Page</a>
        </span>
    </li>
</ul>
```

在上面的示例中，我们使用 `th:if` 属性来判断当前页码的位置。如果当前页码是第一页，则我们使用 `th:each="page : ${#numbers.sequence(1, 3)}"` 来显示前三页的分页链接。如果当前页码在中间，则我们使用 `th:each="page : ${#numbers.sequence(currentPage - 2, currentPage + 2)}"` 来显示前后两页共五页的分页链接。如果当前页码是最后一页，则我们使用 `th:each="page : ${#numbers.sequence(totalPages - 2, totalPages)}"` 来显示最后三页的分页链接。

请注意，您需要根据您的具体需求修改上面的示例，以便指定正确的 URL 和查询参数。

# 9.springmvc不拦截静态资源

[有几种方法可以配置Spring MVC不拦截静态资源。一种方法是在拦截器中添加静态资源的排除（涉及spring-mvc.xml）。另一种方法是使用默认的servlet来处理静态资源（涉及spring-mvc.xml和web.xml）。第三种方法是更改Spring的全局拦截设置，仅拦截以*.do结尾的请求（涉及web.xml）](https://www.cnblogs.com/acme6/p/13673131.html)[1](https://www.cnblogs.com/acme6/p/13673131.html)。

[针对这三种方案的优劣分析：第一种方案配置比较臃肿，多个拦截器时增加文件行数，不推荐使用；第二种方案使用默认的Servlet进行资源文件的访问，Spring拦截所有请求，然后再将资源文件交由默认的Sevlet进行处理，性能上少有损耗；第三种方案Spring只是处理以’.do’结尾的访问，性能上更加高效，但是再访问路径上必须都以’.do’结尾，URL不太文雅；综上所述，推荐使用第二和第三中方案](https://www.cnblogs.com/acme6/p/13673131.html)[1](https://www.cnblogs.com/acme6/p/13673131.html)。

第一种方法是在拦截器中添加静态资源的排除（涉及spring-mvc.xml）。在spring-mvc.xml文件中，可以使用[mvc:resources](mvc:resources)来设置静态资源，然后在[mvc:interceptors](mvc:interceptors)中添加[mvc:interceptor](mvc:interceptor)，并在其中使用[mvc:exclude-mapping](mvc:exclude-mapping)来排除静态资源的拦截。例如，可以使用<mvc:exclude-mapping path=“/**/*.css”/>来排除对所有CSS文件的拦截。

第二种方法是使用默认的servlet来处理静态资源（涉及spring-mvc.xml和web.xml）。在spring-mvc.xml文件中，可以使用[mvc:default-servlet-handler/](mvc:default-servlet-handler/)来启用默认的Servlet。然后，在web.xml文件中，可以添加<servlet-mapping>来增加对静态资源的处理。例如，可以使用<url-pattern>*.css</url-pattern>来指定默认的Servlet处理所有CSS文件。

第三种方法是更改Spring的全局拦截设置，仅拦截以*.do结尾的请求（涉及web.xml）。在web.xml文件中，可以修改<servlet-mapping>来更改Spring的全局拦截设置。例如，可以使用<url-pattern>*.do</url-pattern>来指定Spring仅拦截以.do结尾的请求。这样，Spring就只会处理以.do结尾的请求，不再维护静态资源。

# 10.element vue 分页

```html
    <!-- 引入样式 -->
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <!-- 引入组件库 -->
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
									<el-pagination id="app"
                                                    @size-change="handleSizeChange"
                                                    @current-change="handleCurrentChange"
                                                    :current-page="currentPage"
                                                    :page-sizes="[10, 20, 30, 40]"
                                                    :page-size="pageSize"
                                                    layout="sizes, prev, pager, next, jumper, ->, total, slot"
                                                    :total="PageMAX">
                                            </el-pagination>

<script type="module">
    new Vue({
        el: '#app',
        data() {
            return {
                searchKey: '',
                tableData: [],
                PageMAX: 0,
                currentPage: 1,
                pageSize: 10
            };
        },
        mounted() {
            this.getData();
        },
        methods: {
            async getData() {
                const response = await axios.get('/api/page', {
                    params: {
                        key: this.searchKey,
                        page: this.currentPage,
                        size: this.pageSize,
                    }
                });
                this.tableData = response.data.records;
                this.PageMAX = response.data.pages;
            },
            handleSizeChange(val) {
                this.pageSize = val;
                this.getData();
            },
            handleCurrentChange(val) {
                this.currentPage = val;
                this.getData();
            },
            handleSearch() {
                this.currentPage = 1;
                this.getData();
            }
        }
    })
</script>
```

# 11.html引入qs库，使用方法

<script src="https://cdn.bootcdn.net/ajax/libs/qs/6.10.1/qs.js"></script>
<script type="text/javascript">
   let qs = Qs;
   console.log(qs);
 </script>
# 12.axios post 传入对象

```javascript
  axios.post('/user',
                    {
                        "admin": this.admin
                    },
                    {
                        headers:{
                            "Content-Type": "application/json"
                        }
                    }
```



```java
@ResponseBody
//执行更新
@RequestMapping(value = "/user",method = RequestMethod.POST)
public Object updateUser(@RequestBody Map<String,Object> params){
    // System.out.println(admin);
    // TAdmin admin = (TAdmin) params.get("admin");
    String text = String.valueOf(params.get("admin"));
    Gson gson = new Gson();
    TAdmin admin = gson.fromJson(text, TAdmin.class);
    boolean update = tAdminService.updateById(admin);
    Map<String,Object> result = new HashMap<>();
    result.put("state",update);
    result.put("data",admin);
    return result;
}
```

# 13.axios.delete 不能在请求体传参 要通用方法

```javascript
axios({
    method: 'delete',
    url: '/role',
    data:{
        "roles": this.multipleSelection
    }
})
```

```java
@ResponseBody
@DeleteMapping ("/role")
public Object deleteRole(@RequestBody Map<String,Object> roles) {
    return "200";
}
```

![image-20230407213036612](https://yqlyq.github.io/problemImages/imgs202306072110767.png)

# 14.如果文件导入 404 改完记得清除缓存

# 15.vue项目配合thymeleaf模板前端获取Controller里Model的传值 (string)

以下面代码为例

````java
model.addAttribute("access_token", 'access_token')`
````

前端可以绑定到span标签（input也是可以的，由于该数据不想显示出来所以直接隐藏掉就可以了），页面使用window.document.getElementById获取数据

```xml
<span style="display: none" th:text="${access_token}" id="access_token"></span>

const access_token = window.document.getElementById('access_token').innerText

```

# 16.vue 获取model中的对象什么的

Vue：这样定义属性 一定要加上 <script **th:inline="javascript"**>

```javascript
<script th:inline="javascript">
    var listMenu = [[${listMenu}]];
 
</script>

```

# 17.vue select 穿梭

你想在两个`<select>`元素之间穿梭选项，你可以使用Vue的数据绑定和事件处理功能来实现。例如，你可以使用以下代码来创建两个下拉列表，并在它们之间穿梭选项：

```html
<div class="panel-body" id="app">
                    <form role="form" class="form-inline">
                        <div class="form-group">
                            <label for="exampleInputPassword1">未分配角色列表</label><br>
                            <select v-model="selectedRoleId" class="form-control" multiple size="10"
                                    style="width:120px;overflow-y:auto;">
                                <option v-for="role in UnAssignRole" :value="role.id">{{role.name}}</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <ul>
                                <li class="btn btn-default glyphicon glyphicon-chevron-right" @click="toRightBtn"></li>
                                <br>
                                <li class="btn btn-default glyphicon glyphicon-chevron-left"
                                    style="margin-top:20px;" @click="toLeftBtn"></li>
                            </ul>
                        </div>
                        <div class="form-group" style="margin-left:40px;">
                            <label for="exampleInputPassword1">已分配角色列表</label><br>
                            <select v-model="transferredRoleId" class="form-control" multiple size="10"
                                    style="width:120px;overflow-y:auto;">
                                <option v-for="role in assignRole" :value="role.id">{{role.name}}</option>
                            </select>

                        </div>
                    </form>
                </div>
```

```javascript
data() {
  return {
    selectedRoleId: null,
    transferredRoleId: null,
    roles: [
      { id: 1, name: '角色1' },
      { id: 2, name: '角色2' },
      { id: 3, name: '角色3' }
    ],
    transferredRoles: []
  };
},
methods: {
  transfer() {  var assignRole = [[${assignRoleList}]]
    var UnAssignRole = [[${unAssignRoleList}]]
    new Vue({
        el: "#app",
        data() {
            return {
                transferredRoleId: [],
                selectedRoleId: [],
                assignRole: assignRole,
                UnAssignRole: UnAssignRole
            };

        },
        methods: {
            toRightBtn(){
                this.selectedRoleId.forEach((selectedRoleId) => {
                    const roles = this.UnAssignRole.find(role => role.id === selectedRoleId)
                    this.assignRole.push(roles);
                    this.UnAssignRole = this.UnAssignRole.filter(role => role.id !== selectedRoleId);
                    this.selectedRoleId = [];
                })
            }
        }
    })
          this.selectedRoleId.forEach((selectedRoleId) => {
                    const roles = this.UnAssignRole.find(role => role.id === selectedRoleId)
                    this.assignRole.push(roles);
                    this.UnAssignRole = this.UnAssignRole.filter(role => role.id !== selectedRoleId);
                    this.selectedRoleId = [];
                })
    }
  }
}
```

在上面的代码中，我们首先创建了两个`<select>`元素，并使用`v-model`指令将它们分别绑定到`selectedRoleId`和`transferredRoleId`数据属性上。然后，我们在两个下拉列表之间添加了一个按钮，用来触发穿梭操作。

当用户点击按钮时，我们会调用`transfer`方法来执行穿梭操作。在这个方法中，我们首先根据`selectedRoleId`的值来查找被选中的角色对象。如果找到了这个角色对象，我们就将它从`roles`数组中移除，并添加到`transferredRoles`数组中。最后，我们将`selectedRoleId`的值重置为`null`。

# 18.JavaScript删除列表元素的几种方法

①length
通过减小列表的长度length强制删除最后一个元素

```js
var colors = ["red","blue","green"];
//1--减小length强制删除最后一个元素
colors.length -= 1;
print(1,colors);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106062.png)

②delete关键词
根据下标删除，改位置会被undefine替代，列表长度不变

```js
//2--delete关键词
colors = ["red","blue","green"];
delete colors[0];
print(2,colors);
console.log(colors[0]);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106470.png)

③栈方法
pop()方法默认移除并返回列表最后一项

```js
//3--栈方法
colors = ["red","blue","green"];
var item = colors.pop();
print(3,colors);
console.log(item);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106295.png)

④队列方法
shift()方法默认移除并返回列表的第一项 

```js
//4--队列方法
colors = ["red","blue","green"];
var item = colors.shift();
print(4,colors);
console.log(item);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106080.png)

⑤splice(a,b)方法
向splice()传递两个参数，第一个是开始的下标a，第二个为个数b，则会移除并返回列表第a个元素开始往后的b个元素，返回值为列表 (可以指定删除)

```js
//5-splice()方法
colors = ["red","blue","green"];
var item = colors.splice(0,1);
print(5,colors);
console.log(item);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106486.png)

指定删除

```js
               var index = this.roleIdList.indexOf(transferredRoleId) //查询下标
                    this.roleIdList.splice(index,1) //删除
```



⑥通过迭代判断删除
通过forEach方法，删除符合条件的元素

```js
//6--迭代方法
colors = ["red","blue","green"];
colors.forEach(function (item,index,arr){
    if (item == "green") {
        arr.splice(index,1);
    }
});
print(6,colors);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106134.png)

通过filter方法，返回符合条件的元素列表

```js
colors = ["red","blue","green"];
colors = colors.filter(function (item) {
    return item != "green";
});
print(6,colors);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106358.png)

⑦通过给原型Array添加方法来删除
通过给原型Array添加用于删除的方法来删除元素，好处在于可以复用

用于删除的方法可以很多，此处展示的为其中一种

```js
//7--原型方法
Array.prototype.remove = function (index) {
    if (isNaN(index) || index > this.length) {
        return false;
    }else {
        for (i = 0, n = 0; i < this.length; i++) {
            if (this[i] != this[index]) {
                this[n++] = this[i];
            }
        }
        this.length -= 1;
    }
};
colors = ["red","blue","green"];
colors.remove(1);
print(7,colors);
```
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072106814.png)

# 19.ZTree的使用 （树状显示）

① 创建一个中间表  在 Menu 类中使用 List<Menu> **children** 属性存储当前节点的子节点。

```java
public class Menu {
// 主键
private Integer id;
// 父节点的 id
private Integer pid;
// 节点名称
private String name;
// 节点附带的 URL 地址，是将来点击菜单项时要跳转的地址
private String url;
// 节点图标的样式
private String icon;
// 存储子节点的集合，初始化是为了避免空指针异常
private List<Menu> children = new ArrayList<>();
// 控制节点是否默认为打开装，设置为 true 表示默认打开
private Boolean open = true;
}
```

②获取root 根节点

```java
public ResultEntity<Menu> getWholeTreeNew() {
// 1.查询全部的 Menu 对象
List<Menu> menuList = menuService.getAll();
// 2.声明一个变量用来存储找到的根节点
Menu root = null;
// 3.创建 Map 对象用来存储 id 和 Menu 对象的对应关系便于查找父节点
Map<Integer, Menu> menuMap = new HashMap<>();
// 4.遍历 menuList 填充 menuMap
for (Menu menu : menuList) {
Integer id = menu.getId();
menuMap.put(id, menu);
}
// 5.再次遍历 menuList 查找根节点、组装父子节点
for (Menu menu : menuList) {
// 6.获取当前 menu 对象的 pid 属性值
Integer pid = menu.getPid();
// 7.如果 pid 为 null，判定为根节点
if(pid == null) {
root = menu;
// 8.如果当前节点是根节点，那么肯定没有父节点，不必继续执行
continue ;
}
// 9.如果 pid 不为 null，说明当前节点有父节点，那么可以根据 pid 到 menuMap 中
查找对应的 Menu 对象
Menu father = menuMap.get(pid);
// 10.将当前节点存入父节点的 children 集合
father.getChildren().add(menu);
}
// 11.经过上面的运算，根节点包含了整个树形结构，返回根节点就是返回整个树
return ResultEntity.successWithData(root);
}
```

③**引入** **zTree** **环境**

```css
<link rel="stylesheet" href="ztree/zTreeStyle.css"/>
<script type="text/javascript" src="ztree/jquery.ztree.all-3.5.min.js"></script>

         <div class="panel-body">
                    <ul id="treeDemo" class="ztree"></ul>
         </div>
```

④显示树状

```js
//获取数据
function getTree() {
    $.ajax({
        url: "/menu/tree",
        type: "get",
        dataType: "json",
        success: function (response) {
            var result = response.result;
            if (result === "SUCCESS") {

                var zNodes = response.data;
                $.fn.zTree.init($("#treeDemo"), setting, zNodes);
            }
            if (result === "FAILED") {
                layer.msg(response.message);
            }
        }
    })
}
```

# 20.docker mysql 连接不上 

docker 中安装MySQL :

```dockerfile
docker pull mysql

docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql
```


在docker中安装了mysql后，用SQLyog去连接的时候出现如下错误。

![img](https://yqlyq.github.io/problemImages/imgs202306072106583.png)

解决方法：

1、查看我们想要连接的mysql是否启动

```
#查看在运行的容器
docker ps -s 
```

2、进入容器

```
docker exec -it 容器号或名 /bin/bash

docker exec -it b30062adc08c /bin/bash
```

```
docker exec -it mysql /bin/bash
```

3、进入mysql

```mysql
mysql -uroot -p
```

![img](https://yqlyq.github.io/problemImages/imgs202306072107369.png)

#输入密码（跟之前在windows上运行mysql是一样的）

4、查看MySQL的信息

```mysql
select host,user,plugin,authentication_string from mysql.user;
```

![img](https://yqlyq.github.io/problemImages/imgs202306072106938.png)

备注：host为 % 表示不限制ip localhost表示本机使用 plugin非mysql_native_password 则需要修改密码

6、修改密码

```mysql
mysql> use mysql;
mysql> alter user 'root'@'%' identified with mysql_native_password by '123456';
mysql> flush privileges;
mysql> select host,user,plugin,authentication_string from mysql.user;
```

![img](https://yqlyq.github.io/problemImages/imgs202306072107288.png)


再次用navicat远程连接mysql就成功了

# 21.升级Spring Cloud Alibaba 2021.1，Spring Boot 2.7.10碰到的一系列兼容性问题及解决方案

## 1.bootstrap.yml不生效

发现读取不到Nacos配置中心的配置，后续发现控制台也不显示Nacos相关信息

### 原因

从Spring Boot 2.4版本开始，配置文件加载方式进行了重构。

````xml
<!-- 引入bootstrap -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
````

## 2.通过spring gateway访问其他服务503 service unavailable

### 原因

Spring Cloud 2020.0.0版本之前会自动引入Netflix Ribbon依赖,Netflix Ribbon功能跟loadbalancer一样,因Netflix公司停止维护Ribbon后, 在Spring Cloud 2020.0.0版本之后Spring使用loadbalancer替代了Ribbon, 但是loadbalancer依赖需要手动引入。


### 解决方案

```xml
# 引入loadbalancer

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-loadbalancer</artifactId>
</dependency>
```

### 后续问题

增加loadbalancer后启动提示：Spring Cloud LoadBalancer is currently working with the default cache. You can switch to using Caffeine cache, by adding it and org.springframework.cache.caffeine.CaffeineCacheManager to the classpath

解决方案是引入caffeine，或者关闭cache

```xml
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>3.1.0</version>
</dependency>

```

#### 访问其他服务时提示：LoadBalancerCacheManager not available, returning delegate without caching

```xml
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-context-support</artifactId>
  <version>5.2.21.RELEASE</version>
</dependency>

```

# 22.vue-cli 初始化失败

Failed to download repo vuejs-templates/webpacke: Response code 404 (Not Found)

执行下面三个命令来检查环境：

node -v(小写v) ；如果没有显示node版本，先去官网下载安装node
vue -V(大写V) ；如果没有显示vue版本，npm i vue-cli -g安装
webpack -v(小写v)； 如果需要重新安装，就用 npm install webpack -g  和 npm i -g webpack-cli

# 23 .跨域 从8001访问88，引发CORS跨域请求，浏览器会拒绝跨域请求 

跨域
问题描述：已拦截跨源请求：同源策略禁止读取位于 http://localhost:88/api/sys/login 的远程资源。（原因：CORS 头缺少 ‘Access-Control-Allow-Origin’）。

问题分析：这是一种跨域问题。访问的域名和端口和原来的请求不同，请求就会被限制

跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对js施加的安全限制。（ajax可以）

同源策略：是指协议，域名，端囗都要相同，其中有一个不同都会产生跨域；

![img](https://yqlyq.github.io/problemImages/imgs202306072107727.png)

跨域流程： 这个跨域请求的实现是通过预检请求实现的，先发送一个OPSTIONS探路，收到响应允许跨域后再发送真实请求![img](https://yqlyq.github.io/problemImages/imgs202306072107983.png)

前面跨域的解决方案： 方法1：设置nginx包含admin和gateway 方法2：让服务器告诉预检请求能跨域

![img](https://yqlyq.github.io/problemImages/imgs202306072107055.png)

![img](https://yqlyq.github.io/problemImages/imgs202306072108076.png)



解决方法：在网关中定义“GulimallCorsConfiguration”类，该类用来做过滤，允许所有的请求跨域。

```java


@Configuration // gateway
public class GulimallCorsConfiguration {

    @Bean // 添加过滤器
    public CorsWebFilter corsWebFilter(){
        // 基于url跨域，选择reactive包下的
        UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();
        // 跨域配置信息
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 允许跨域的头
        corsConfiguration.addAllowedHeader("*");
        // 允许跨域的请求方式
        corsConfiguration.addAllowedMethod("*");
        // 允许跨域的请求来源
        corsConfiguration.addAllowedOrigin("*");
        // 是否允许携带cookie跨域
        corsConfiguration.setAllowCredentials(true);
        
       // 任意url都要进行跨域配置
        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }
}

```

# 24.【跨域问题】When allowCredentials is true, allowedOrigins cannot contain the special value “*“ since that

在springboot中配置跨域时，出现When allowCredentials is true, allowedOrigins cannot contain the special value “*” since that cannot be set on the “Access-Control-Allow-Origin” response header. To allow credentials to a set of origins, list them explicitly or consider using “allowedOriginPatterns” instead.

浏览器显示500服务器报错
需要将配置类中的corsConfiguration.addAllowedOrigin("");修改成为corsConfiguration.addAllowedOriginPattern("");

**修改前的代码：**

```java
@Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        // 配置跨域
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 允许哪个请求头
        corsConfiguration.addAllowedHeader("*");
        // 允许哪个方法进行跨域
        corsConfiguration.addAllowedMethod("*");
        // 允许哪个请求来源进行跨域
       	corsConfiguration.addAllowedOrigin("*");
        // 是否允许携带cookie进行跨域
        corsConfiguration.setAllowCredentials(true);

        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }

```

**修改后：**

```java
 @Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        // 配置跨域
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 允许哪个请求头
        corsConfiguration.addAllowedHeader("*");
        // 允许哪个方法进行跨域
        corsConfiguration.addAllowedMethod("*");
        // 允许哪个请求来源进行跨域
        // corsConfiguration.addAllowedOrigin("*");
        corsConfiguration.addAllowedOriginPattern("*");
        // 是否允许携带cookie进行跨域
        corsConfiguration.setAllowCredentials(true);

        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }

```

# 25.gateway Unable to find RoutePredicateFactory with name path（报错解决）

**path中的p没有大写Path**

![img](https://yqlyq.github.io/problemImages/imgs202306072109911.png)

\- Path=/user/**，还有‘=’ 中间不能有空格

# 26.vue设置axios请求接口基址和代理接口地址

**适用于vue-cli3以上版本搭建的项目**
一、接口基址（单个接口地址）
如果你的项目只有一个服务器访问地址（接口地址），不调用别的接口地址的话可以直接在src下的main.js中设置[axios](https://so.csdn.net/so/search?q=axios&spm=1001.2101.3001.7020)的默认基址

```vue
//main.js中
import axios from 'axios'
Vue.prototype.$axios = axios
axios.defaults.baseURL='http://localhost:3000';//设置基址
```

例子如下

```vue
//example.vue
<template>
  <div></div>
</template>

<script>
export default {
  name: 'example',
  data(){
    return{
    }
  },
  mounted(){
   this.login()
  },
  methods:{     
    //登录接口
    login(){
      this.$axios.post('/login',{
          id:111,
          psw:'1111111'
      }).then(res=>{
        console.log(res)
      })

    }
  }
}
</script>


```

二、代理接口地址
如果你的项目需要访问多个地址，即调用多个不同的接口来进行数据的交互，这个时候应该设置代理地址
在项目根目录下新建一个vue.config.js文件

![img](https://yqlyq.github.io/problemImages/imgs202306072108070.png)

```vue
//vue.config.js
module.exports = {
   devServer: {
    host: 'localhost',
    port: 8080,//本地运行的端口
    open: true, //配置自动启动浏览器 
    hotOnly:false,
    //接口代理
      proxy: {
        '/news': {
          target: 'http://v.juhe.cn/toutiao',//设置要代理访问的接口---这是头条的接口
          changeOrigin: true,
          pathRewrite: {
            '^/news': ''//重写访问地址，在请求时可以省略target的地址，直接以/news开头
          }
        },
        '/api': {
          target: 'http://localhost:3000',//设置要代理访问的接口----这是我自己的接口
          changeOrigin: true,
          pathRewrite: {
            '^/api': ''  //重写访问地址，在请求时可以省略target的地址，直接以/api开头
          }
        }
      }
   }, 

```

例子如下

```vue
//example.vue
<template>
  <div></div>
</template>

<script>
export default {
  name: 'example',
  data(){
    return{
    }
  },
  mounted(){
   this.login()
   this.getnews();
  },
  methods:{
    getnews(){
      //获取头条信息
      this.$axios.get('/news/index',{params:{
        key:'d2f47f5d5981c66091cfa284cecfd781',
        type:'头条'
      }}).then(res=>{
        console.log(res)
      })
    },
    //登录接口
    login(){
      this.$axios.post('/api/login',{
          id:111,
          psw:'111111'
      }).then(res=>{
        console.log(res)
      })

    }
  }
}
</script>


```

# 27.axios 发送 错误JSON parse error: Cannot deserialize value of type Interage

 原因是 

```java
public Result delete(@RequestBody Long[] ids){
        //效验数据
        AssertUtils.isArrayEmpty(ids, "id");

        categoryService.deleteMenuById(Arrays.asList(ids));

        return new Result();
    }
```

用List[] 接收

之前axios 是 data：{} 带了key 所以接收不到

```
  data: {
    firstName: 'Fred'
  },
  
  // 发送请求体数据的可选语法
  // 请求方式 post
  // 只有 value 会被发送，key 则不会
  data: 'Country=Brasil&City=Belo Horizonte',
```

# 28.element中switch v-model绑定的值为数字类型情形

在用到el-switch组件时，需要绑定数据为number类型，但总也绑不成功
 element官方文档上说：设置该组件的active-value和inactive-value属性，可接受Boolean, String或Number类型的值。

找的解决办法：
 1，使用number将绑定的v-model改为number类型

```xml
<el-switch
        active-value=1
        inactive-value=0
        v-model.number=scope.row.locked>
</el-switch>
```

这样没用，连switch按钮都绑定不上去

2、后来发现，当value为Number类型的时候active-value和inactive-value前边必须加：单项绑定一下才可以。
 而active-value和inactive-value等号后边的值得引号是可有可无的。

```csharp
<el-switch
      :active-value=1
      :inactive-value=0
      v-model="scope.row.locked">
</el-switch>
```

**Vue中的数据绑定**
 绑定数据有三种方式：

- 插值，也就是{{name}}的形式，以文本的形式和实例data中对应的属性进行绑定
- v-bind
- v-model
   v-bind
   eg：v-bind:class 可简写为 :class

当加上v-bind:之后，它的值classe不是字符串，而是vue实例对应的data.classed的这个变量。也就是说data.classed是什么值，它就会给class属性传递什么值，当data.classed发生变化的时候，class属性也发生变化，这非常适合用在通过css来实现动画效果的场合。他只是单向变动

v-bind支持的类型
 html中的属性、css的样式、对象、数组、number 类型、bool类型

v-bind使用：

```jsx
// 绑定文本
<p v-bind="message"></p>
 
// 绑定属性
<p v-bind:src="http://...."></p>
<p v-bind:class="http://...."></p>
<p v-bind:style="http://...."></p>
 
// 绑定表达式
:class{className:true}
```

v-model
 主要是用在表单元素中，它实现了双向绑定。在同事使用v-bind和v-model中，v-model建立的双向绑定对输入型元素input, textarea, select等具有优先权，会强制实行双向绑定。很多时候v-model使用在表单的<input>中实现双向绑定。

```xml
<input v-model="something">
```

# 29.nacos 新获取配置

```yaml
        extension-configs:
          - data-id: datasource.yaml
            group: dev
            refresh: true
```

# 30.springboot 整合cos

### 开通腾讯云COS

#### 创建存储桶

![img](https://yqlyq.github.io/problemImages/imgs202306072108783.png)

请求域名可做拼接文件访问URL使用

然后下一步即可

![img](https://yqlyq.github.io/problemImages/imgs202306072108942.png)

![img](https://yqlyq.github.io/problemImages/imgs202306072108336.png)

**上传**文件时需要以上红框参数

### 导入依赖

```xml
<dependency>
       <groupId>com.qcloud</groupId>
       <artifactId>cos_api</artifactId>
       <version>5.6.89</version>
</dependency>
```



### 配置文件yml

```yaml
tencent:
  cos:
    file:
      keyId: keyId
      keySecret: keySecret
      bucketName: ed-1302656006
      regionId: ap-guangzhou
      cosHost: https://{请求域名} #例：https://ed-1302656006.cos.ap-guangzhou.myqcloud.com

```

### 配置类

```java
@Component
@ConfigurationProperties(prefix = "tencent.cos.file")
@Data
public class CosConfig {

    private String keyId;
    private String keySecret;
    private String bucketName;
    private String regionId;
    private String cosHost;
}

```

### Controller

实际需分层(service/impl)，这里仅为记录

```java
@PutMapping()
public String uploadCosFile(@RequestPart("file") MultipartFile multipartFile) {
    COSClient cosClient = initCosClient();
    // spring直接使用File接收文件传参，会有问题(No primary or single unique constructor found for class java.io.File)不知道具体原因，之后再看。
    // 腾讯云上传方法参数需要File,做一个转换操作
    File file = MultipartFileToFile(multipartFile);
    PutObjectRequest putObjectRequest = new PutObjectRequest(cosConfig.getBucketName(), key, file);
    //对象键（Key）是对象在存储桶中的唯一标识。例如，在对象的访问域名 examplebucket-1250000000.cos.ap-guangzhou.myqcloud.com/images/picture.jpg 中，对象键（key）为 images/picture.jpg
    //如果images文件夹不存在则创建
    cosClient.putObject(putObjectRequest);
    client.shutdown();  // 关闭cos客户端
    //ResponseParam为自定义返回json格式
    return cosConfig.getCosHost() + "/" + key;
}

```

```java
/**
* 获取腾讯云COS客户端
* @return COSClient
*/
private COSClient initCosClient() {
    COSCredentials cred = new BasicCOSCredentials(cosConfig.getKeyId(), cosConfig.getKeySecret());
    Region region = new Region(cosConfig.getRegionId());
    ClientConfig clientConfig = new ClientConfig(region);
    clientConfig.setHttpProtocol(HttpProtocol.https);
    return new COSClient(cred, clientConfig);
}

```

```java
/**
* 接口只能接受MultipartFile, 腾讯云需要File
* 故 MultipartFile => File
* @param multiFile 上传文件
* @return file
*/
public static File MultipartFileToFile(MultipartFile multiFile) {
    // 获取文件名
    String fileName = multiFile.getOriginalFilename();
    // 获取文件后缀
    String suffix = fileName.substring(fileName.lastIndexOf("."));
    try {
         // 防止生成的临时文件重复,文件名随机码, UUID
        File file = File.createTempFile(UUID.randomUUID().toString().replaceAll("-", ""), suffix);
        multiFile.transferTo(file);
        return file;
    } catch (Exception e) {
        e.printStackTrace();
        throw new 自定义异常(code, "MultipartFileToFile 文件转换异常");
    }
}

```

转载 https://blog.csdn.net/Memory_y/article/details/127955778?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-127955778-blog-121015175.235%5Ev32%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-127955778-blog-121015175.235%5Ev32%5Epc_relevant_default_base3&utm_relevant_index=6

# 32.OSS上传

## 后端

```yaml
在“ gulimall-third-party”命名空间中，创建“ gulimall-third-party.yml”文件
spring:
  cloud:
    alicloud:
      access-key: 
      secret-key: 
      oss:
        endpoint: 
        bucker:
```



```java
@Data
@Component
@ConfigurationProperties(prefix = "oss.yaml")
@RefreshScope
public class OssConfig {
    @Value("${spring.cloud.alicloud.oss.endpoint}")
    String endpoint;

    @Value("${spring.cloud.alicloud.oss.bucket}")
    String bucket;

    @Value("${spring.cloud.alicloud.access-key}")
    String accessId;
    @Value("${spring.cloud.alicloud.secret-key}")
    String accessKey;
}
```

```java
@Service
public class OssServiceImpl implements OssService {
    @Resource
    OssConfig ossConfig;
    @Resource
    OSSClient ossClient;
    //获取签名
    @Override
    public Map<String, String> getPolicy() {
        String host = "https://" + ossConfig.getBucket() + "." + ossConfig.getEndpoint(); // host的格式为 bucketname.endpoint

        String format = new SimpleDateFormat("yyyy-MM-dd").format(new Date());
        String dir = "product/"+format; // 用户上传文件时指定的前缀。

        Map<String, String> respMap = null;
        try {
            long expireTime = 30;
            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
            Date expiration = new Date(expireEndTime);
            PolicyConditions policyConds = new PolicyConditions();
            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);

            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
            byte[] binaryData = postPolicy.getBytes("utf-8");
            String encodedPolicy = BinaryUtil.toBase64String(binaryData);
            String postSignature = ossClient.calculatePostSignature(postPolicy);

            respMap = new LinkedHashMap<String, String>();
            respMap.put("accessid", ossConfig.getAccessId());
            respMap.put("policy", encodedPolicy);
            respMap.put("signature", postSignature);
            respMap.put("dir", dir);
            respMap.put("host", host);
            respMap.put("expire", String.valueOf(expireEndTime / 1000));

        } catch (Exception e) {
            // Assert.fail(e.getMessage());
            System.out.println(e.getMessage());
        } finally {
            ossClient.shutdown();
        }
        return respMap;
    }
}
```

```java
 @Autowired
    OssService ossService;
    @GetMapping("/policy")
    public Map<String,String> getPolicy(){
        return ossService.getPolicy();
    }
```

## 前端上传

```vue
<template>
  <div>
    <el-upload
      action="#"
      :data="dataObj"
      list-type="picture"
      :multiple="false"
      :show-file-list="showFileList"
      :file-list="fileList"
      :before-upload="beforeUpload"
      :on-remove="handleRemove"
      :on-success="handleUploadSuccess"
      :on-preview="handlePreview"
    >
      <el-button size="small" type="primary">点击上传</el-button>
      <div slot="tip" class="el-upload__tip">
        只能上传jpg/png文件，且不超过10MB
      </div>
    </el-upload>
    <el-dialog :visible.sync="dialogVisible">
      <img width="100%" :src="fileList[0].url" alt="" />
    </el-dialog>
  </div>
</template>
<script>
import { policy } from './policy'
import { getUUID } from '@/utils'

export default {
  name: 'singleUpload',
  props: {
    value: String,
  },
  computed: {
    imageUrl() {
      return this.value
    },
    imageName() {
      if (this.value != null && this.value !== '') {
        return this.value.substr(this.value.lastIndexOf('/') + 1)
      } else {
        return null
      }
    },
    fileList() {
      return [
        {
          name: this.imageName,
          url: this.imageUrl,
        },
      ]
    },
    showFileList: {
      get: function() {
        return (
          this.value !== null && this.value !== '' && this.value !== undefined
        )
      },
      set: function(newValue) {},
    },
  },
  data() {
    return {
      dataObj: {
        policy: '',
        signature: '',
        key: '',
        ossaccessKeyId: '',
        dir: '',
        host: '',
        // callback:'',
      },
      dialogVisible: false,
    }
  },
  methods: {
    emitInput(val) {
      this.$emit('input', val)
    },
    handleRemove(file, fileList) {
      this.emitInput('')
    },
    handlePreview(file) {
      this.dialogVisible = true
    },
    //上传前操作获取签名
    beforeUpload(file) {
      let _self = this
      return new Promise((resolve, reject) => {
        this.$axios({
          url: '/thirdparty/oss/policy',
          method: 'get',
        })
          .then((response) => {
            _self.dataObj.policy = response.data.policy
            _self.dataObj.signature = response.data.signature
            _self.dataObj.ossaccessKeyId = response.data.accessid
            _self.dataObj.key =
              response.data.dir + '/' + getUUID() + '_${filename}'
            _self.dataObj.dir = response.data.dir
            _self.dataObj.host = response.data.host
            resolve(true)
          })
          .catch((err) => {
            reject(false)
          })
      })
    },
    handleUploadSuccess(res, file) {
      console.log('上传成功...')
      this.showFileList = true
      this.fileList.pop()
      this.fileList.push({
        name: file.name,
        url:
          this.dataObj.host +
          '/' +
          this.dataObj.key.replace('${filename}', file.name),
      })
      this.emitInput(this.fileList[0].url)
    },
  },
}
</script>
<style></style>

```

# 33.JSR303

## 问题引入：填写form时应该有前端校验，后端也应该有校验

### 前端

前端的校验是element-ui表单验证
Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。

### 后端

@NotNull等
步骤1：使用校验注解
在Java中提供了一系列的校验方式，它这些校验方式在“javax.validation.constraints”包中，提供了如@Email，@NotNull等注解。

```xml
<!--jsr3参数校验器-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

里面依赖了hibernate-validator
在非空处理方式上提供了@NotNull，@NotBlank和@NotEmpty

#### 1 @NotNull

The annotated element must not be null. Accepts any type.
注解元素禁止为null，能够接收任何类型

#### 2 @NotEmpty

the annotated element must not be null nor empty.

该注解修饰的字段不能为null或""

Supported types are:

支持以下几种类型

CharSequence (length of character sequence is evaluated)字符序列（字符序列长度的计算）
Collection (collection size is evaluated)
集合长度的计算
Map (map size is evaluated)
map长度的计算
Array (array length is evaluated)
数组长度的计算

#### 3 @NotBlank

The annotated element must not be null and must contain at least one non-whitespace character. Accepts CharSequence.
该注解不能为null，并且至少包含一个非空格字符。接收字符序列。

#### @Valid

#### 步骤2：controller中加校验注解@Valid，开启校验，

```markdown

@RequestMapping("/save")
public R save(@Valid @RequestBody BrandEntity brand){
    brandService.save(brand);

    return R.ok();
}
测试： http://localhost:88/api/product/brand/save
```

![img](https://yqlyq.github.io/problemImages/imgs202306072109488.png)

![img](https://yqlyq.github.io/problemImages/imgs202306072109670.png)

validator”的“\org\hibernate\validator\ValidationMessages_zh_CN.properties”文件中。在该文件中定义了很多的错误规则：

javax.validation.constraints.AssertFalse.message     = 只能为false
javax.validation.constraints.AssertTrue.message      = 只能为true

```java

想要自定义错误消息，可以覆盖默认的错误提示信息，如@NotBlank的默认message是
public @interface NotBlank {

	String message() default "{javax.validation.constraints.NotBlank.message}";
}
可以在添加注解的时候，修改message：
@NotBlank(message = "品牌名必须非空")
private String name;

```

![img](https://yqlyq.github.io/problemImages/imgs202306072109319.png)

但是这种返回的错误结果并不符合我们的业务需要。

BindResult

#### 步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。

```java
@RequestMapping("/save")
public R save(@Valid @RequestBody BrandEntity brand, BindingResult result){    
    if( result.hasErrors()){        
       Map<String,String> map=new HashMap<>();                //1.获取错误的校验结果   	
        result.getFieldErrors().forEach((item)->{       
        //获取发生错误时的message            
        String message = item.getDefaultMessage();              //获取发生错误的字段            
        String field = item.getField();            				map.put(field,message);        
    });        
    return R.error(400,"提交的数据不法").put("data",map); 
}else { 
    
}   
brandService.save(brand);
return R.ok();}
```

这种是针对于该请求设置了一个内容校验，如果针对于每个请求都单独进行配置，显然不是太合适，实际上可以统一的对于异常进行处理。

统一异常处理@ControllerAdvice

#### 步骤4：统一异常处理

可以使用SpringMvc所提供的@ControllerAdvice，通过“basePackages”能够说明处理哪些路径下的异常。

##### 1 抽取一个异常处理类

```java
@Slf4j
    @RestControllerAdvice(basePackages = "com.atguigu.gulimall.product.controller")
    public class GulimallExceptionControllerAdvice {

        @ExceptionHandler(value = Exception.class) // 也可以返回ModelAndView
        public R handleValidException(MethodArgumentNotValidException exception) {

            Map<String, String> map = new HashMap<>();
            // 获取数据校验的错误结果
            BindingResult bindingResult = exception.getBindingResult();
            bindingResult.getFieldErrors().forEach(fieldError -> {
                String message = fieldError.getDefaultMessage();
                String field = fieldError.getField();
                map.put(field, message);
            });

            log.error("数据校验出现问题{},异常类型{}", exception.getMessage(), exception.getClass());

            return R.error(400, "数据校验出现问题").put("data", map);
        }
    }
```

##### 2 测试： http://localhost:88/api/product/brand/save

![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202305021609957.png)

#### 3 默认异常处理

```java
   @ExceptionHandler(value = Throwable.class)
    public R handleException(Throwable throwable){
        log.error("未知异常{},异常类型{}",throwable.getMessage(),throwable.getClass());
        return R.error(400,"数据校验出现问题");
    }
```

#### 4 错误状态码

上面代码中，针对于错误状态码，是我们进行随意定义的，然而正规开发过程
中，错误状态码有着严格的定义规则，如该在项目中我们的错误状态码定义

![img](https://yqlyq.github.io/problemImages/imgs202306072109241.png)

为了定义这些错误状态码，我们可以单独定义一个常量类，用来存储这些错误状态码

```java
package com.yxj.common.exception;

/***
 * 错误码和错误信息定义类
 * 1. 错误码定义规则为5为数字
 * 2. 前两位表示业务场景，最后三位表示错误码。例如：100001。10:通用 001:系统未知异常
 * 3. 维护错误码后需要维护错误描述，将他们定义为枚举形式
 * 错误码列表：
 *  10: 通用
 *      001：参数格式校验
 *  11: 商品
 *  12: 订单
 *  13: 购物车
 *  14: 物流
 */
public enum BizCodeEnum {

    UNKNOW_EXEPTION(10000,"系统未知异常"),

    VALID_EXCEPTION( 10001,"参数格式校验失败");

    private int code;
    private String msg;

    BizCodeEnum(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}

```

![img](https://yqlyq.github.io/problemImages/imgs202306072109414.png)

## 自定义校验功能

场景：要校验showStatus的01状态，可以用正则，但我们可以利用其他方式解决
复杂场景。比如我们想要下面的场景

显示状态[0-不显示；1-显示]

```java
@NotNull(groups = {AddGroup.class, UpdateStatusGroup.class})
@ListValue(vals = {0,1}, groups = {AddGroup.class, UpdateGroup.class, UpdateStatusGroup.class})
private Integer showStatus;
```

添加依赖

````xml
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
````

### 1 编写自定义的校验注解

必须有3个属性

message()错误信息
groups()分组校验
payload()自定义负载信息

```java
@Documented
@Constraint(validatedBy = { ListValueConstraintValidator.class})
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface ListValue {
    // 使用该属性去Validation.properties中取
    String message() default "{com.atguigu.common.valid.ListValue.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    int[] value() default {};
}
```

该属性值取哪里取呢？
    common创建文件ValidationMessages.properties
    里面写上com.atguigu.common.valid.ListValue.message=必须提交指定的值 [0,1]

### 2 编写自定义的校验器

```java
public class ListValueConstraintValidator implements ConstraintValidator<ListValue,Integer> {
    private Set<Integer> set=new HashSet<>();
    @Override
    public void initialize(ListValue constraintAnnotation) {
        int[] value = constraintAnnotation.value();
        for (int i : value) {
            set.add(i);
        }

    }

    @Override
    public boolean isValid(Integer value, ConstraintValidatorContext context) {


        return  set.contains(value);
    }
}
```

### 3 关联校验器和校验注解

@Constraint(validatedBy = { ListValueConstraintValidator.class})
一个校验注解可以匹配多个校验器

### 4 使用实例

```java
/**

  * 显示状态[0-不显示；1-显示]
    */
    @ListValue(value = {0,1},groups ={AddGroup.class})
    private Integer showStatus;


```

# 34.前端检验



```vue
 computed: {
    dataRule() {
      return {
      firstLetter: [
          {
            validator: (rule, value, callback) => {
              if (value === '') {
                callback(new Error('首字母为空'))
              } else if (!/^[a-zA-Z]$/.test(value)) {
                callback(new Error('填写必须是a-z或者A-Z'))
              } else {
                callback()
              }
            },
    
            trigger: 'blur',
          },
        ],
        sort: [
          {
            validator: (rule, value, callback) => {
              if (value === '') {
                callback(new Error('排序为空'))
              } else if (
                !Number.isInteger(parseInt(value)) ||
                parseInt(value) < 0
              ) {
                callback(new Error('排序字段必须是一个整数'))
              } else {
                callback()
              }
            },
          
            trigger: 'blur',
          },
        ],
      }
      }
      }
```

# 35."Cannot read property 'length' of undefined"报错处理

ue的数据绑定在刚开始只是和内存建立联系，并没有真正的和后台的数据挂上钩，所以一开始的val.reportArray只是一个空值，必须在之前加个if判断，确保有值以后再开始计算length

```vue

	       if(val.reportArray){
            this.projectReportSumNum = val.reportArray.length;
          }

```

# 36.vue 重置 data 属性

vue中：
`this.$data` 获取当前状态下的data
`this.$options.data()` 获取该组件初始状态下的data

所以，下面就可以将初始状态的data复制到当前状态的data，实现重置效果：

```vue
Object.assign(this.$data, this.$options.data())
```

当然，如果你只想重置data中的某一个对象或者属性：

````vue
this.form = this.$options.data().form
````

# 37.idea 重命名和全局替换快捷键

使用ctrl + f 或者 ctrl + r的方式在当前的页面是管用的，跨页面就不好使了。
使用ctrl + shift + f 或者ctrl + shift + r是可以完成整个项目的相同字符串的更改。但是往往不同的类可能有相同的属性名字，这显然是不能一起改的。
使用shift + F6可以实现重命名，会将所有用到当前这个变量的名称都替换掉。

# 38.前后端传输Date类型数据时格式化日期

问题一：
后台在返回json格式的[Date类](https://so.csdn.net/so/search?q=Date类&spm=1001.2101.3001.7020)型数据时，直接通过@ResponseBody返回出去的是一个长整型时间戳：

![img](https://yqlyq.github.io/problemImages/imgs202306072054983.png)

解决方法：
@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”,timezone = “GMT+8”)

它的作用是，出参时，自动把Date型对象数据转化成格式化后的字符串输出: yyyy-MM-dd HH:mm:ss

案例：
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072054235.png)

- timezone是用于调整时区的属性(东八区)，不加的话得到的时间会比实际的少8个小时

- Postman请求结果：

  ![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072054872.png)

问题二：
前端以字符串的形式给后台传递 带有格式的 日期 和 数字 数据，导致后台无法解析数据：

![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072054025.png)
解决方法：
![在这里插入图片描述](https://yqlyq.github.io/problemImages/imgs202306072054898.png)
总结：
1.如果前后端传的数据都是json格式，那么后台接数据，传数据都可以用@JsonFormat ;

2.@DateTimeFormat适合后端接收前端传来的数据，不管是不是json格式都可以正确转换成Date型数据，只要前端传来的格式正确且后端@DateTimeFormat的pattern写正确。但是，这个注解无法将Date型数据用json传到前端去

**解决spring boot接收前端传递过来的json数据时，接收到的时间与实际传递时间不一致的问题**

spring boot接收前端传递过来的时间，总是比实际时间晚几个小时或者早几个小时，这是由于使用在@RequestBody 实体类，进行接收json类型字符串的时候，会把接受的string时间字段转换成lang类型，然后对应实体类的时候，会按照GMT+0时区的时间进行处理。

解决办法：
1，使用@JsonFormat注解，并且指定时区

```java
@JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone="GMT+8")
private Date timingDate;

```

2，使用@DateTimeFormat注解，但此方法在pattern="yyyy-MM-dd HH:mm:ss"时不适用Jackson，只支持时间类型为pattern="yyyy-MM-dd"的。

```java
@DateTimeFormat(pattern="yyyy-MM-dd")
private Date timingDate;

```

3，Controller接收时，按照json字符串接收，然后代码对应到bean里时，特殊处理时间字段。
需要使用到net.sf.json。

import net.sf.json.JSONObject;

import net.sf.json.util.JSONUtils;

```
@RequestMapping("/insideByJson.tml")
public @ResponseBody Map<String, Object> insideByJson(@RequestBody String jsonParam) {
	//json字符串转换成bean
	JSONObject json=JSONObject.fromObject(jsonParam);
	String[] dateFormats = new String[]{"yyyy-MM-dd HH:mm:ss","yyyy-MM-dd"};  
        JSONUtils.getMorpherRegistry().registerMorpher(new DateMorpher(dateFormats));
        Inside inside=(Inside) JSONObject.toBean(json, Inside.class);
}

```

# 39.java将Object对象转换成实体类对象

利用 com.fasterxml.jackson.databind.ObjectMapper 包下的 convertValue方法可将对象转换为对应的实体类对象

```
convertValue(Object fromValue, Class<T> toValueType)
```

应用代码如下:

![img](https://yqlyq.github.io/problemImages/imgs202306072054336.png)

关于解决localDateTime转换出错问题, 数据类型Date, 但转换对象为LocalDateTime, 则需要加下方两行设置

```java
//解决localDateTime转换出错问题
objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
objectMapper.registerModule(new JavaTimeModule());
```

# 40.【Linux】CentOS防火墙操作：开启端口、开启、关闭、配置

### 🔶 基本使用

启动： systemctl start firewalld
关闭： systemctl stop firewalld
查看状态： systemctl status firewalld 
开机禁用  ： systemctl disable firewalld
开机启用  ： systemctl enable firewalld

# 41.docker中设置Kibana为中文

## Kibana将语言设置为中文

1.1 查看Kibana容器id

```
docker ps 
```

1.2 进入容器

```applescript
docker exec -it Kibana容器id bash
```

1.3 进入config 目录下

```arduino
cd config/
```

1.4 编辑 kibana.yml 文件

```nginx
vi kibana.yml 
```

1.5 添加一行配置即可

```avrasm
i18n.locale: "zh-CN"
```

1.6 退出容器

```awk
exit
```

1.7 重启Kibana（需要1分钟 别着急）

```applescript
docker restart Kibana容器id
```

# 42.es

## 1._ca 

```
Get /_cat/health	//查看es健康状况
Get /_cat/nodes //查看所有节点
Get /_cat/master //查看主节点
Get /_cat/indices //查看所有索引 等价于mysql数据库的show databases;
```

## 2.查看elasticsearch版本信息： http://ip:9200

## 3.保存

保存一个数据，保存在哪个索引的哪个类型下（哪张数据库哪张表下），保存时用唯一标识指定
PUT customer/external/1

在customer索引下的external类型下保存1号数据为
{
 "name":"John Doe"
}

PUT和POST都可以
POST新增。如果不指定id，会自动生成id。指定id就会修改这个数据，并新增版本号；
PUT可以新增也可以修改。PUT必须指定id；由于PUT需要指定id，我们一般用来做修改操作，不指定id会报错。
唯一区分是post不指定id时永远为创建

```
post customer/external/ 
不带id 则是新增
post customer/external/1
带id 如果之前有数据则是修改 或者新增
```

## 查看文档

```
GET /customer/external/1

http://192.168.56.10:9200/customer/external/1
{
    "_index": "customer",
    "_type": "external",
    "_id": "1",
    "_version": 10,
    "_seq_no": 18,//并发控制字段，每次更新都会+1，用来做乐观锁
    "_primary_term": 6,//同上，主分片重新分配，如重启，就会变化
    "found": true,
    "_source": {
        "name": "John Doe"
    }
}

```

## 乐观锁

通过“if_seq_no=1&if_primary_term=1”，当序列号匹配的时候，才进行修改，否则不修改。

## 更新文档_update

```markdown
POST customer/externel/1/_update
{
    "doc":{
        "name":"111"
    }
}
或者
POST customer/externel/1
{
    "doc":{
        "name":"222"
    }
}
或者
PUT customer/externel/1
{
    "doc":{
        "name":"222"
    }
}


```

不同：带有update情况下

POST操作会对比源文档数据，如果相同不会有什么操作，文档version不增加。
PUT操作总会重新保存并增加version版本
POST时带_update对比元数据如果一样就不进行任何操作。

看场景：

对于大并发更新，不带update
对于大并发查询偶尔更新，带update；对比更新，重新计算分配规则
POST更新文档，带有_update

## 更改mapping 数据迁移

```
PUT /product
{
  "mappings": { 
  "properties": {
    "attrs": {
      "type": "nested",
      "properties": {
        "attrId": {
          "type": "long"
        },
        "attrName": {
          "type": "keyword"
        },
        "attrValue": {
          "type": "keyword"
        }
      }
    },
    "brandId": {
      "type": "long"
    },
    "brandImg": {
      "type": "keyword"
    },
    "brandName": {
      "type": "keyword"
    },
    "catalogId": {
      "type": "long"
    },
    "catalogName": {
      "type": "keyword"
    },
    "categoryId": {
      "type": "long"
    },
    "categoryName": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "hasStock": {
      "type": "boolean"
    },
    "hotScore": {
      "type": "long"
    },
    "saleCount": {
      "type": "long"
    },
    "skuId": {
      "type": "long"
    },
    "skuImg": {
      "type": "keyword"
    },
    "skuPrice": {
      "type": "float"
    },
    "skuTitle": {
      "type": "text",
      "analyzer": "ik_smart"
    },
    "spuId": {
      "type": "keyword"
    }
  }
}},
```

迁移

```
POST _reindex
{
  "source": {
    "index": "my_index"
  },
  "dest": {
    "index": "product"
  }
}
```



# 43.thymealeaf 如果总无法加载出来

看看有没有 @EnableWebMvc  然后删掉

在Spring Boot中使用@EnableWebMvc也可能遇到类似的问题，@EnableWebMvc是使用注解方式快捷配置Spring Webmvc的一个注解。在使用时你可能会遇到以下问题：

Spring Boot在application文件中的配置失效
在Spring Boot的自定义配置类加上@EnableWebMvc后，发现自动配置的静态资源路径（classpath:/META/resources/，classpath:/resources/，classpath:/static/，classpath:/public/）资源无法访问。

通过查看@EnableWebMvc的源码，可以发现该注解就是为了引入一个DelegatingWebMvcConfiguration 配置类，而DelegatingWebMvcConfiguration又继承于WebMvcConfigurationSupport。也就是说，如果我们使用@EnableWebMvc就相当于导入了WebMvcConfigurationSupport类，这个时候，Spring Boot的自动装配就不会发生了，我们能用的，只有WebMvcConfigurationSupport提供的若干个配置。其实不使用@EnableWebMvc注解也是可以实现配置Webmvc，只需要将配置类继承于WebMvcConfigurationSupport类即可。

当使用@EnableWebMvc时，加载的是WebMvcConfigurationSupport中的配置项。

当不使用@EnableWebMvc时，使用的是WebMvcAutoConfiguration引入的配置项。
————————————————
版权声明：本文为CSDN博主「zxc123e」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zxc123e/article/details/84636521

# 44.虚拟机ping不到主机 主机可以ping到虚拟机

在VMware里，依次点击”编辑“ - ”虚拟网络编辑器“，如下图，我选择的是NAT模式：

![这里写图片描述](https://yqlyq.github.io/problemImages/imgs202306072054651.png)

为了能够使用静态IP，这里不要勾选”使用本地DHCP服务将IP分配给虚拟机“这个选项。然后是配置子网ip，子网IP与宿主机的ip一定不能处在同一地址范围里，否则就算虚拟机能上网，网络既慢，还不稳定。我主机的ip段是192.168.5.xxx，所以我配了192.168.10.xxx来避开主机的ip段，反正ip的第三个数字在0到254并且不是5就行。Nat模式相当于配置了一个子路由器，有设置过多级路由的朋友对此应该有所体会。各位结合自己机器的IP来合理配置一个子网ip吧。

在这个界面接着点”NAT设置”，查看虚拟机的网关，这个网关在第三步要用。我这里的网关是192.168.10.2。
![这里写图片描述](https://yqlyq.github.io/problemImages/imgs202306072054295.png)

**最后**
‘/etc/sysconfig/network-scripts/ifcfg-ens33’ 修改内容

TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static #设置成静态
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=d6fe4d6d-7756-4aed-bd77-19f1cab20841
DEVICE=ens33
ONBOOT=yes #这里如果为no的话就改为yes，表示网卡设备自动启动
NM_CONTROLLED=no
DNS1=8.8.8.8 #dns服务器1，填写你所在的网络可用的dns服务器地址即可
DNS2=4.2.2.2 #dns服器2
IPADDR=192.168.10.150 #配置ip，在第上一步已经设置ip处于192.168.10.xxx这个范围，我就随便设为150了，只要不和网关相同均可
NETMASK=255.255.255.0 #子网掩码
GATEWAY=192.168.10.2 #这里的网关地址就是上一步步获取到的那个网关地址
————————————————
service network restart 即可

# 45.配置nginx的反向代理nginx.conf：

全局块：配置影响nginx全局的指令。如：用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process故障等
events块：配置影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。
http块：
http全局块：配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。错误页面等
server块：这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的。每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。

```markdown
location1：配置请求的路由，以及各种页面的处理情况
location2
server {
    listen       80;
    server_name  gulimall.com;
#charset koi8-r;
#access_log  /var/log/nginx/log/host.access.log  main;

location / {
    #又转回到本机
    proxy_pass http://192.168.56.1:10000;
}

#error_page  404              /404.html;

# redirect server error pages to the static page /50x.html
#
error_page   500 502 503 504  /50x.html;
location = /50x.html {
    root   /usr/share/nginx/html;
}

# proxy the PHP scripts to Apache listening on 127.0.0.1:80
#
#location ~ \.php$ {
#    proxy_pass   http://127.0.0.1;
#}

# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
#
#location ~ \.php$ {
#    root           html;
#    fastcgi_pass   127.0.0.1:9000;
#    fastcgi_index  index.php;
#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
#    include        fastcgi_params;
#}

# deny access to .htaccess files, if Apache's document root
# concurs with nginx's one
#
#location ~ /\.ht {
#    deny  all;
#}
```
}

## Nginx+网关

修改hosts，映射gulimall.com到192.168.56.10(本机地址)。关闭防火墙

修改nginx/conf/nginx.conf，将upstream映射到我们的网关服务
    upstream gulimall{
        # 88是网关
        server 192.168.56.1:88;
    }


修改nginx/conf/conf.d/gulimall.conf，接收到gulimall.com的访问后，如果是/，转交给指定的upstream，由于nginx的转发会丢失host头，造成网关不知道原host，所以我们添加头信息

location / {
      proxy_pass http://gulimall;
      proxy_set_header Host $host;
}


配置gateway为服务器，将域名为**.gulimall.com转发至商品服务。配置的时候注意 网关优先匹配的原则，所以要把这个配置放到后面
    - id: gulimall_host_route
          uri: lb://gulimall-product
          predicates:
            - Host=**.gulimall.com


测试：http://gulimall.com/api/product/attrgroup/list/1

http://localhost:88/api/product/attrgroup/list/1

请求结果相同

此时请求接口和请求页面都是gulimall.com

# 46.解决jmeter.bat文件双击无法启动问题

**有可能是环境变量导致，删除了JMETER_HOME后重新双击jmeter.bat执行，成功。**

# 47.java优化工具

## 在命令行敲 jconsole

![image-20230519114424235](https://yqlyq.github.io/problemImages/imgs202306072054000.png)

点击线程

![image-20230519114525695](https://yqlyq.github.io/problemImages/imgs202306072055945.png)

## 或者 jvisualvm

![image-20230519115102970](https://yqlyq.github.io/problemImages/imgs202306072055768.png)

# 48一般优化策略

## 缓存

### 本地缓存

使用Map<String,Object> 适用数据不常更新 减少mysql io

### 分布式缓存

redis

# 49.JSON 转对象或者其他

引入 阿里巴巴的JSON

```xml
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
    <version>2.0.31</version>
</dependency>
```

```
转换成map
JSON.parseObject(catelogJson, new TypeReference<Map<String, List<Level2Vo>>>() {});
```

# 50.电脑的ipv4地址每次重启后自动还原

1.调出cmd窗口

2.输入命令

```perl
netsh int ip reset C;resetlog.txt
```

按回车

3.重启电脑，重新设置ip即可

总结：

netsh 命令重置 TCP/IP协议，使其恢复到初次安装操作系统时的状态。具体操作如下： 
点击“开始 运行”，在运行对话框中输入“CMD”命令，弹出命令提示符窗口，接着输入“netsh int ip reset c:\resetlog.txt”命令后会回车即可，其中“resetlog.txt”文件是用来记录命令执行结果的日志文件，该参数选项必须指定，这里指定的日志文件的完整路径是“c:\resetlog.txt。执行此命令后的结果与删除并重新安装 TCP/IP 协议的效果相同。

# 51.缓存

## 本地缓存

```
Map<String,Object> map = new HashMap<>();
if(map.get("key")!=null){
retrun map.get()
}else {
	调用数据库
}
```

## 分布式缓存

本地缓存问题：每个微服务都要有缓存服务、数据更新时只更新自己的缓存，造
成缓存数据不一致

解决方案：分布式缓存，微服务共用 缓存中间件


分布式锁
分布式项目时，但本地锁只能锁住当前服务，需要分布式锁

redis分布式锁的原理：setnx，同一时刻只能设置成功一个
前提，锁的key是一定的，value可以变

没获取到锁阻塞或者sleep一会

设置好了锁，玩意服务出现宕机，没有执行删除锁逻辑，这就造成了死锁

解决：设置过期时间
业务还没执行完锁就过期了，别人拿到锁，自己执行完去删了别人的锁

解决：锁续期（redisson有看门狗），。删锁的时候明确是自己的锁。如uuid
判断uuid对了，但是将要删除的时候锁过期了，别人设置了新值，那删除了别人
的锁

解决：删除锁必须保证原子性（保证判断和删锁是原子的）。使用redis+Lua脚本
完成，脚本是原子的

lua脚本

```

if redis.call("get",KEYS[1]) == ARGV[1] 
then
	return redis.call("del",KEYS[1])
else
    return 0
end;

```

```java
//调用
String script = "if redis.call("get",KEYS[1]) == ARGV[1] 
then
	return redis.call("del",KEYS[1])
else
    return 0
end;";

stringRedisTemplate.execute(
    new DefaultRedisScript<Long返回值类型>(script脚本支付非常, Long.class返回值类型), 
    Arrays.asList("lock"), // 键key的集合
    lockValue);
```

上面的lua脚本写法每次用分布式锁时比较麻烦 并且JUC用不了，我们可以采用redisson现有框架

https://redis.io/docs/manual/patterns/distributed-locks/

https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95

```
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.21.3</version>
</dependency>
```

# 52.常用的正则表达式

## 1.匹配url的比如页码

```markdown
'/(' + "pageNum" + '=)([^&]*)/gi'
```

# 53.Stream 返回map 以id为索引 对象为数据

```
    Map<Long, SearchResult.AttrVo> attrMap = searchResult.getAttrs().stream().collect(Collectors.toMap(SearchResult.AttrVo::getAttrId, Function.identity()));
```

# 54.替换成utf-8的中文编码

```
        encode = URLEncoder.encode(value, "UTF-8").replace("+", "%20");
```

# 55.异步&线程池

## 1、初始化线程的4种方式

1）、继承 Thread

2）、实现 Runnable接口

3)、实现Callable接口 + FutureTask（可以拿到返回结果，可以处理异常)

4)、线程池

方式1和方式2:主进程无法获取线程的运算结果。不适合当前场景

方式3:主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。

方式4:通过如下两种方式初始化线程池

```java
Executors.newFiexedThreadPool(3);
//或者
new ThreadPoolExecutor(corePoolSize, maximumPoolSize， keepAliveTime,TimeUnit unit,workQueue, threadEactory, handler);
```


通过线程池性能稳定，也可以获取执行结果，并捕获异常。但是，在业务复杂情况下，一个异步调用可能会依赖于另一个异步调用的执行结果。

## 2.七大参数

corePoolSize:[5]核心线程数[一直存在除非（allowCoreThreadTimeOut)];线程池，创建好以后就准备5个线程

maximumPoolSize:[200]最大线程数量;控制资源

keepAliveTime:存活时间。如果当前的线程数量大于core数量。

unit:时间单位 释放空闲的线程(maximumPoolSize-corePoolSize)。只要线程空闲大丁指定的keepALiveTime;

BLockingQueue<Runnable>workQueue :阻塞队列。如果任务有很多，就会将目前多的任务放在队列里面。只要有线程空闲,就会去队列里面取出新的任务继续执行。

threadFactory :线程的创建工厂。

RejectedExecutionHandLer handLer:如果队列满了，按照我们指定的拒绝策略拒绝执行任务

运行流程:
1、线程池创建，准备好core数量的核心线程，准备接受任务

2、新的任务进来，用core准备好的空闲线程执行。
(1)、core满了，就将再进来的任务放入阻塞队列中。空闲的core就会自己去阻塞队
列获取任务执行
(2)、阻塞队列满了，就直接开新线程执行，最大只能开到max指定的数量
(3)、max都执行好了。Max-core数量空闲的线程会在keepAliveTime,指定的时间后自动销毁。最终保持到core大小
(4)、如果线程数开到了max的数量，还有新任务进来，就会使用reject 指定的拒绝策略进行处理
3、所有的线程创建都是由指定的 factory创建的。

## 3.线程池四种创建方式

**Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：**

**newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。**

**newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。**

**newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。**

**newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。**

## 4.为什么用

Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序
都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。
第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，
还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用
线程池，必须对其实现原理了如指掌。

# 56.CompletableFuture 异步编排

一、创建异步任务
--------

### 1\. supplyAsync

supplyAsync是创建带有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（[ForkJoinPool](https://so.csdn.net/so/search?q=ForkJoinPool&spm=1001.2101.3001.7020).commonPool()）的方法，一个是带有自定义线程池的重载方法

```java
// 带返回值异步请求，默认线程池
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
 
// 带返回值的异步请求，可以自定义线程池
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)
 
```

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> cf = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            return "result";
        });
 
        //等待任务执行完成
        System.out.println("结果->" + cf.get());
}
 
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 自定义线程池
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture<String> cf = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            return "result";
        }, executorService);
 
        //等待子任务执行完成
        System.out.println("结果->" + cf.get());
}
```

 测试结果：

![](https://yqlyq.github.io/problemImages/imgs202306072055569.png)

###  2\. runAsync

runAsync是创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法

```java
// 不带返回值的异步请求，默认线程池
public static CompletableFuture<Void> runAsync(Runnable runnable)
 
// 不带返回值的异步请求，可以自定义线程池
public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
```

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Void> cf = CompletableFuture.runAsync(() -> {
            System.out.println("do something....");
        });
 
        //等待任务执行完成
        System.out.println("结果->" + cf.get());
}
 
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 自定义线程池
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture<Void> cf = CompletableFuture.runAsync(() -> {
            System.out.println("do something....");
        }, executorService);
 
        //等待任务执行完成
        System.out.println("结果->" + cf.get());
}
```

测试结果：

![](https://yqlyq.github.io/problemImages/imgs202306072055392.png)

### 3.获取任务结果的方法

```java
// 如果完成则返回结果，否则就抛出具体的异常
public T get() throws InterruptedException, ExecutionException 
 
// 最大时间等待返回结果，否则就抛出具体异常
public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
 
// 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 CompletableFuture所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因
public T join()
 
// 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。
public T getNow(T valueIfAbsent)
 
// 如果任务没有完成，返回的值设置为给定值
public boolean complete(T value)
 
// 如果任务没有完成，就抛出给定异常
public boolean completeExceptionally(Throwable ex) 
 
```

 二、异步回调处理
---------

### 1.thenApply和thenApplyAsync

 thenApply 表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，带有返回值。

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Integer> cf2 = cf1.thenApplyAsync((result) -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            result += 2;
            return result;
        });
        //等待任务1执行完成
        System.out.println("cf1结果->" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
}
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Integer> cf2 = cf1.thenApply((result) -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            result += 2;
            return result;
        });
        //等待任务1执行完成
        System.out.println("cf1结果->" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
}
```

测试结果：

![](https://yqlyq.github.io/problemImages/imgs202306072055776.png)
   ![](https://yqlyq.github.io/problemImages/imgs202306072055208.png)

从上面代码和测试结果我们发现thenApply和thenApplyAsync区别在于，使用thenApply方法时子任务与父任务使用的是同一个线程，而thenApplyAsync在子任务中是另起一个线程执行任务，并且thenApplyAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。

### 2.thenAccept和thenAcceptAsync

 thenAccep表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，无返回值。

测试代码

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Void> cf2 = cf1.thenAccept((result) -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });
 
        //等待任务1执行完成
        System.out.println("cf1结果->" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
}
 
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Void> cf2 = cf1.thenAcceptAsync((result) -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });
 
        //等待任务1执行完成
        System.out.println("cf1结果->" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
}
```

测试结果：

![](https://yqlyq.github.io/problemImages/imgs202306072055824.png)
 ![](https://yqlyq.github.io/problemImages/imgs202306072055009.png)
从上面代码和测试结果我们发现thenAccep和thenAccepAsync区别在于，使用thenAccep方法时子任务与父任务使用的是同一个线程，而thenAccepAsync在子任务中可能是另起一个线程执行任务，并且thenAccepAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。

### 2.thenRun和thenRunAsync

 thenRun表示某个任务执行完成后执行的动作，即回调方法，无入参，无返回值。

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Void> cf2 = cf1.thenRun(() -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });
 
        //等待任务1执行完成
        System.out.println("cf1结果->" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
}
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Void> cf2 = cf1.thenRunAsync(() -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });
 
        //等待任务1执行完成
        System.out.println("cf1结果->" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
}
```

 测试结果：

![](https://yqlyq.github.io/problemImages/imgs202306072055617.png)

![](https://yqlyq.github.io/problemImages/imgs202306072055207.png)

从上面代码和测试结果我们发现thenRun和thenRunAsync区别在于，使用thenRun方法时子任务与父任务使用的是同一个线程，而thenRunAsync在子任务中可能是另起一个线程执行任务，并且thenRunAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。

### 3.whenComplete和whenCompleteAsync

 whenComplete是当某个任务执行完成后执行的回调方法，会将执行结果或者执行期间抛出的异常传递给回调方法，如果是正常执行则异常为null，回调方法对应的CompletableFuture的result和该任务一致，如果该任务正常执行，则get方法返回执行结果，如果是执行异常，则get方法抛出异常。

测试代码：

```java
 public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            int a = 1/0;
            return 1;
        });
 
        CompletableFuture<Integer> cf2 = cf1.whenComplete((result, e) -> {
            System.out.println("上个任务结果：" + result);
            System.out.println("上个任务抛出异常：" + e);
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });
 
//        //等待任务1执行完成
//        System.out.println("cf1结果->" + cf1.get());
//        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
    }
```

测试结果：

![](https://yqlyq.github.io/problemImages/imgs202306072055520.png)


 whenCompleteAsync和whenComplete区别也是whenCompleteAsync可能会另起一个线程执行任务，并且thenRunAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。

### 4.handle和handleAsync

 跟whenComplete基本一致，区别在于handle的回调方法有返回值。

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            // int a = 1/0;
            return 1;
        });
 
        CompletableFuture<Integer> cf2 = cf1.handle((result, e) -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            System.out.println("上个任务结果：" + result);
            System.out.println("上个任务抛出异常：" + e);
            return result+2;
        });
 
        //等待任务2执行完成
        System.out.println("cf2结果->" + cf2.get());
}
```

测试结果 ：

![](https://yqlyq.github.io/problemImages/imgs202306072055047.png)

## 三、多任务组合处理 

### 1.thenCombine、thenAcceptBoth 和runAfterBoth

这三个方法都是将两个CompletableFuture组合起来处理，只有两个任务都正常完成时，才进行下阶段任务。

区别：thenCombine会将两个任务的执行结果作为所提供函数的参数，且该方法有返回值；thenAcceptBoth同样将两个任务的执行结果作为方法入参，但是无返回值；runAfterBoth没有入参，也没有返回值。注意两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果。

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Integer> cf2 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            return 2;
        });
 
        CompletableFuture<Integer> cf3 = cf1.thenCombine(cf2, (a, b) -> {
            System.out.println(Thread.currentThread() + " cf3 do something....");
            return a + b;
        });
 
        System.out.println("cf3结果->" + cf3.get());
}
 
 public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Integer> cf2 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            return 2;
        });
        
        CompletableFuture<Void> cf3 = cf1.thenAcceptBoth(cf2, (a, b) -> {
            System.out.println(Thread.currentThread() + " cf3 do something....");
            System.out.println(a + b);
        });
 
        System.out.println("cf3结果->" + cf3.get());
}
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });
 
        CompletableFuture<Integer> cf2 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            return 2;
        });
 
        CompletableFuture<Void> cf3 = cf1.runAfterBoth(cf2, () -> {
            System.out.println(Thread.currentThread() + " cf3 do something....");
        });
 
        System.out.println("cf3结果->" + cf3.get());
}
```

测试结果：

![](https://yqlyq.github.io/problemImages/imgs202306072056001.png)


![](https://yqlyq.github.io/problemImages/imgs202306072056207.png)

![](https://yqlyq.github.io/problemImages/imgs202306072056665.png)

### 2.applyToEither、acceptEither和runAfterEither

这三个方法和上面一样也是将两个CompletableFuture组合起来处理，当有一个任务正常完成时，就会进行下阶段任务。

区别：applyToEither会将已经完成任务的执行结果作为所提供函数的参数，且该方法有返回值；acceptEither同样将已经完成任务的执行结果作为方法入参，但是无返回值；runAfterEither没有入参，也没有返回值。

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf1 任务完成";
        });
 
        CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf2 任务完成";
        });
 
        CompletableFuture<String> cf3 = cf1.applyToEither(cf2, (result) -> {
            System.out.println("接收到" + result);
            System.out.println(Thread.currentThread() + " cf3 do something....");
            return "cf3 任务完成";
        });
 
        System.out.println("cf3结果->" + cf3.get());
}
 
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf1 任务完成";
        });
 
        CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf2 任务完成";
        });
 
        CompletableFuture<Void> cf3 = cf1.acceptEither(cf2, (result) -> {
            System.out.println("接收到" + result);
            System.out.println(Thread.currentThread() + " cf3 do something....");
        });
 
        System.out.println("cf3结果->" + cf3.get());
}
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf1 任务完成");
            return "cf1 任务完成";
        });
 
        CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf2 任务完成");
            return "cf2 任务完成";
        });
 
        CompletableFuture<Void> cf3 = cf1.runAfterEither(cf2, () -> {
            System.out.println(Thread.currentThread() + " cf3 do something....");
            System.out.println("cf3 任务完成");
        });
 
        System.out.println("cf3结果->" + cf3.get());
}
```

测试结果： 

![](https://yqlyq.github.io/problemImages/imgs202306072056610.png)

![](https://yqlyq.github.io/problemImages/imgs202306072056799.png)
从上面可以看出cf1任务完成需要2秒，cf2任务完成需要5秒，使用applyToEither组合两个任务时，只要有其中一个任务完成时，就会执行cf3任务，显然cf1任务先完成了并且将自己任务的结果传值给了cf3任务，cf3任务中打印了接收到cf1任务完成，接着完成自己的任务，并返回cf3任务完成；acceptEither和runAfterEither类似，acceptEither会将cf1任务的结果作为cf3任务的入参，但cf3任务完成时并无返回值；runAfterEither不会将cf1任务的结果作为cf3任务的入参，它是没有任务入参，执行完自己的任务后也并无返回值。

### 3.allOf / anyOf 

allOf：CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null。

anyOf ：CompletableFuture是多个任务只要有一个任务执行完成，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回执行完成任务的结果。

测试代码：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf1 任务完成");
            return "cf1 任务完成";
        });
 
        CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                int a = 1/0;
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf2 任务完成");
            return "cf2 任务完成";
        });
 
        CompletableFuture<String> cf3 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf3 任务完成");
            return "cf3 任务完成";
        });
 
        CompletableFuture<Void> cfAll = CompletableFuture.allOf(cf1, cf2, cf3);
        System.out.println("cfAll结果->" + cfAll.get());
}
 
 
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf1 任务完成");
            return "cf1 任务完成";
        });
 
        CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf2 任务完成");
            return "cf2 任务完成";
        });
 
        CompletableFuture<String> cf3 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf3 任务完成");
            return "cf3 任务完成";
        });
 
        CompletableFuture<Object> cfAll = CompletableFuture.anyOf(cf1, cf2, cf3);
        System.out.println("cfAll结果->" + cfAll.get());
}
```

测试结果：

![](https://yqlyq.github.io/problemImages/imgs202305312316214.png)

 ![](https://yqlyq.github.io/problemImages/imgs202305312314991.png)

# 57.idea 无法复制粘贴

sb微软快捷键冲突

# 58.springboot 实现 邮箱发送

1.基础知识
------

**什么是SMTP？**

SMTP全称为Simple Mail Transfer Protocol（**简单邮件传输协议**），它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP认证要求必须提供账号和密码才能登陆服务器，其设计目的在于避免用户受到垃圾邮件的侵扰。

**什么是POP3？**

POP3全称为Post Office Protocol 3（**邮局协议**），POP3支持客户端远程管理服务器端的邮件。POP3常用于“离线”邮件处理，即允许客户端下载服务器邮件，然后服务器上的邮件将会被删除。目前很多POP3的邮件服务器只提供下载邮件功能，服务器本身并不删除邮件，这种属于改进版的POP3协议。

2.传输协议
------

**SMTP协议**  
**发送邮件**：我们通常把处理用户**smtp请求**(邮件发送请求)的服务器称之为SMTP服务器(邮件发送服务器)。

**POP3协议**  
**接收邮件**：我们通常把处理用户**pop3请求**(邮件接收请求)的服务器称之为POP3服务器(邮件接收服务器)。

3.进阶知识
------

*   什么是`JavaMailSender`和`JavaMailSenderImpl`？

**JavaMailSender和JavaMailSenderImpl** 是Spring官方提供的集成邮件服务的接口和实现类，以简单高效的设计著称，目前是Java后端发送邮件和集成邮件服务的主流工具。

*   如何通过`JavaMailSenderImpl`发送邮件？

非常简单，直接**在业务类注入JavaMailSenderImpl并调用send方法发送邮件**。**其中简单邮件可以通过SimpleMailMessage来发送邮件，而复杂的邮件（例如添加附件）可以借助MimeMessageHelper来构建MimeMessage发送邮件**。  
例如：

```java
    @Autowired
    private JavaMailSenderImpl mailSender;

    public void sendMail() throws MessagingException {
        
        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
        simpleMailMessage.setFrom("admin@163.com");
        simpleMailMessage.setTo("socks@qq.com");
        simpleMailMessage.setSubject("Happy New Year");
        simpleMailMessage.setText("新年快乐！");
        mailSender.send(simpleMailMessage);

        
        MimeMessage mimeMessage = mailSender.createMimeMessage();
        MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage);
        messageHelper.setFrom("admin@163.com");
        messageHelper.setTo("socks@qq.com");
        messageHelper.setSubject("Happy New Year");
        messageHelper.setText("新年快乐！");
        messageHelper.addInline("doge.gif", new File("xx/xx/doge.gif"));
        messageHelper.addAttachment("work.docx", new File("xx/xx/work.docx"));
        mailSender.send(mimeMessage);
    }

```

*   为什么`JavaMailSenderImpl` 能够开箱即用 ？

所谓开箱即用其实就是**基于官方内置的自动配置**，翻看源码可知晓**邮件自动配置类(MailSenderPropertiesConfiguration) 为上下文提供了邮件服务实例(JavaMailSenderImpl)**。具体源码如下：

```java
@Configuration
@ConditionalOnProperty(prefix = "spring.mail", name = "host")
class MailSenderPropertiesConfiguration {
    private final MailProperties properties;
    MailSenderPropertiesConfiguration(MailProperties properties) {
        this.properties = properties;
    }
    @Bean
    @ConditionalOnMissingBean
    public JavaMailSenderImpl mailSender() {
        JavaMailSenderImpl sender = new JavaMailSenderImpl();
        applyProperties(sender);
        return sender;
    }

```

其中`MailProperties`是关于邮件服务器的配置信息，具体源码如下：

```java
@ConfigurationProperties(prefix = "spring.mail")
public class MailProperties {
    private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
    private String host;
    private Integer port;
    private String username;
    private String password;
    private String protocol = "smtp";
    private Charset defaultEncoding = DEFAULT_CHARSET;
    private Map<String, String> properties = new HashMap<>();
}

```

1.开启邮件服务
--------

**这里以QQ邮箱为例。** 

首先登录QQ邮箱>>>登录成功后找到设置>>>然后找到邮箱设置>>>点击账户>>>找到POP3|SMTP服务>>>点击开启(开启需要验证，验证成功后会有一串授权码用于发送邮件使用)>>>验证成功  
![](https://yqlyq.github.io/problemImages/imgs202306072056442.png)

![](https://yqlyq.github.io/problemImages/imgs202306072056632.png)

点击开启IMAP/SMTP服务：  
![](https://yqlyq.github.io/problemImages/imgs202306072056911.png)

记下QQ邮箱提示的授权码：  
![](https://yqlyq.github.io/problemImages/imgs202306072056025.png)

这个授权码，就是发送邮件时需要的密码。

以上步骤完成之后，就可以开始开发了。

> **注意：授权码一定记得复制出来**

2.项目创建，引入依赖
-----------

在springboot项目中，引入如下依赖：

```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-web</artifactId>  
</dependency>  
<dependency>  
        <groupId>org.springframework.boot</groupId>  
        <artifactId>spring-boot-starter-mail</artifactId>  
</dependency>  

```

3.application.yml配置
-------------------

在配置文件application.yml文件中写入发送邮件的配置信息

```yaml
server:
  port: 20000
spring:
  thymeleaf:
    cache: false
  mail:
    host: smtp.qq.com
    username: 邮箱
    password: 授权码
    port: 587 //465 必须写下面的properties
    default-encoding: utf-8
    //测试
    test-connection: true
    protocol: smtp
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          ssl:
           enable: true
          socketFactory:
            port: 465
            class: javax.net.ssl.SSLSocketFactory
debug: true
```

4.编写发送邮件方法
----------

**编写邮件业务类MailService，分三种发送邮件类型：纯文本邮件、html邮件和带附件的邮件。** 

主要通过MailService工具类就可以满足发送java邮件的需要。当我们进行好 yml 配置后，SpringBoot会帮助我们自动配置 JavaMailSender 我们通过这个java类就可以实现操作java来发送邮件。

### 4.1 发送纯文本邮件

```java
package com.example.emaildemo.service;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import javax.mail.MessagingException;
import java.util.Date;


@Service
public class MailService {
    private static final Logger logger = LoggerFactory.getLogger(MailService.class);

    
    @Autowired
    private JavaMailSenderImpl javaMailSender;

    @Value("${spring.mail.username}")
    private String sendMailer;

    
    private void checkMail(String to,String subject,String text){
        if(StringUtils.isEmpty(to)){
            throw new RuntimeException("邮件收信人不能为空");
        }
        if(StringUtils.isEmpty(subject)){
            throw new RuntimeException("邮件主题不能为空");
        }
        if(StringUtils.isEmpty(text)){
            throw new RuntimeException("邮件内容不能为空");
        }
    }

    
    public void sendTextMailMessage(String to,String subject,String text){

        try {
            
            MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(javaMailSender.createMimeMessage(),true);
            
            mimeMessageHelper.setFrom(sendMailer);
            
            mimeMessageHelper.setTo(to.split(","));
            
            mimeMessageHelper.setSubject(subject);
            
            mimeMessageHelper.setText(text);
            
            mimeMessageHelper.setSentDate(new Date());

            
            javaMailSender.send(mimeMessageHelper.getMimeMessage());
            System.out.println("发送邮件成功："+sendMailer+"->"+to);

        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("发送邮件失败："+e.getMessage());
        }
    }
}


```

### 4.2 发送html邮件

Spring Boot支持使用HTML发送邮件是通过MimeMessage来完成的。

```java
 /**
     * 发送html邮件
     * @param to
     * @param subject
     * @param content
     */
    public void sendHtmlMailMessage(String to,String subject,String content){

        content="<!DOCTYPE html>\n" +
                "<html>\n" +
                "<head>\n" +
                "<meta charset=\"utf-8\">\n" +
                "<title>邮件</title>\n" +
                "</head>\n" +
                "<body>\n" +
                "\t<h3>这是一封HTML邮件！</h3>\n" +
                "</body>\n" +
                "</html>";
        try {
            //true 代表支持复杂的类型
            MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(javaMailSender.createMimeMessage(),true);
            //邮件发信人
            mimeMessageHelper.setFrom(sendMailer);
            //邮件收信人  1或多个
            mimeMessageHelper.setTo(to.split(","));
            //邮件主题
            mimeMessageHelper.setSubject(subject);
            //邮件内容   true 代表支持html
            mimeMessageHelper.setText(content,true);
            //邮件发送时间
            mimeMessageHelper.setSentDate(new Date());

            //发送邮件
            javaMailSender.send(mimeMessageHelper.getMimeMessage());
            System.out.println("发送邮件成功："+sendMailer+"->"+to);

        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("发送邮件失败："+e.getMessage());
        }
    }

```



### 4.3 发送带附件的邮件

**MimeMessageHelper支持发送复杂邮件模板，支持文本、附件、HTML、图片等**。比如需要发送附件，则在上面的代码中通过调用helper的addAttachment(fileName, file)方法即可。

```java
 /**
     * 发送带附件的邮件
     * @param to      邮件收信人
     * @param subject 邮件主题
     * @param content 邮件内容
     * @param filePath 附件路径
     */
    public void sendAttachmentMailMessage(String to,String subject,String content,String filePath){
        try {
            //true 代表支持复杂的类型
            MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(javaMailSender.createMimeMessage(),true);
            //邮件发信人
            mimeMessageHelper.setFrom(sendMailer);
            //邮件收信人  1或多个
            mimeMessageHelper.setTo(to.split(","));
            //邮件主题
            mimeMessageHelper.setSubject(subject);
            //邮件内容   true 代表支持html
            mimeMessageHelper.setText(content,true);
            //邮件发送时间
            mimeMessageHelper.setSentDate(new Date());
            //添加邮件附件
            FileSystemResource file = new FileSystemResource(new File(filePath));
            String fileName = file.getFilename();
            mimeMessageHelper.addAttachment(fileName, file);

            //发送邮件
            javaMailSender.send(mimeMessageHelper.getMimeMessage());
            System.out.println("发送邮件成功："+sendMailer+"->"+to);

        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("发送邮件失败："+e.getMessage());
        }
    }
```



5.发送邮件接口
--------

新建SendMailController类，编写测试接口

### 5.1 发送纯文本邮件

```java
package com.example.emaildemo.controller;

import com.example.emaildemo.service.MailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@RequestMapping("/mail")
public class SendMailController {

    @Autowired
    private MailService mailService;


    
    @RequestMapping("/sendTextMail")
    public void sendTextMail(String to,String subject,String text){
        mailService.sendTextMailMessage(to,subject,text);
    }
}


```

### 5.2 发送HTML邮件

```java
package com.example.emaildemo.controller;

import com.example.emaildemo.service.MailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@RequestMapping("/mail")
public class SendMailController {

    @Autowired
    private MailService mailService;


    
    @RequestMapping("/sendTextMail")
    public void sendTextMail(String to,String subject,String text){
        mailService.sendTextMailMessage(to,subject,text);
    }

    
    @RequestMapping("/sendHtmlMailMessage")
    public void sendHtmlMailMessage(String to,String subject,String content){
        mailService.sendHtmlMailMessage(to,subject,content);
    }
}


```

### 5.3 发送带附件的邮件

```java
package com.example.emaildemo.controller;

import com.example.emaildemo.service.MailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@RequestMapping("/mail")
public class SendMailController {

    @Autowired
    private MailService mailService;


    
    @RequestMapping("/sendTextMail")
    public void sendTextMail(String to,String subject,String text){
        mailService.sendTextMailMessage(to,subject,text);
    }

    
    @RequestMapping("/sendHtmlMailMessage")
    public void sendHtmlMailMessage(String to,String subject,String content){
        mailService.sendHtmlMailMessage(to,subject,content);
    }

    
    @RequestMapping("/sendAttachmentMailMessage")
    public void sendAttachmentMailMessage(String to,String subject,String content,String filePath){
        
        filePath="D:\\1.png";
        mailService.sendAttachmentMailMessage(to,subject,content,filePath);
    }
}


```

6.测试发送邮件
--------

启动项目，使用postman进行测试

### 6.1 测试纯文本邮件发送

在postman中输入如下接口和参数，点击Send

![](https://yqlyq.github.io/problemImages/imgs202306072056720.png)
控制台显示，发送邮件成功：

![](https://yqlyq.github.io/problemImages/imgs202306072056104.png)

收件邮件：  
![](https://yqlyq.github.io/problemImages/imgs202306072057079.png)

### 6.2 测试html邮件发送

在postman中输入如下接口和参数，点击Send

![](https://yqlyq.github.io/problemImages/imgs202306072057832.png)

控制台显示，发送邮件成功：

![](https://yqlyq.github.io/problemImages/imgs202306072057161.png)

收件邮件：  
![](https://yqlyq.github.io/problemImages/imgs202306072057487.png)

### 6.3 测试带附件的邮件发送

在postman中输入如下接口和参数，点击Send  
![](https://yqlyq.github.io/problemImages/imgs202306072057080.png)

![](https://yqlyq.github.io/problemImages/imgs202306072057528.png)

收件邮件：  
![](https://yqlyq.github.io/problemImages/imgs202306072057200.png)



# 59.Java普通方法实现 邮箱

## 1.基础

使用JavaMail API和JavaActivation Framework（JAF）库

## 2.开启邮箱的SMTP

### 2.1网易邮箱

要在Java中使用网易邮箱SMTP服务器发送电子邮件，需要了解以下几个步骤：

1. 申请网易邮箱的SMTP服务，打开网易邮箱，登录并进入邮箱的设置。
2. 在左侧导航栏中找到“客户端授权密码”，点击“开启服务”。
3. 输入登录密码并点击确认，生成授权码。这是后面需要用到的，所以请妥善保管好授权码。
4. 添加JavaMail API和Java Activation Framework（JAF） JAR文件到你的Java项目中。
5. 编写Java程序，使用JavaMail API和JAF库来发送电子邮件

### 2.2QQ邮箱

使用Java发送QQ邮箱电子邮件的方法与使用网易邮箱类似。以下是一些使用QQ邮箱SMTP服务器发送电子邮件的步骤：

1. 如未开启，请登录QQ邮箱，打开设置页面，找到“账户”选项卡，并开启“POP3/IMAP/SMTP/Exchange/CalDAV/CardDAV服务”。
2. 在“SMTP”下面的“开启SMTP服务”中获取授权码。
3. 添加JavaMail API和Java Activation Framework (JAF) JAR文件到你的Java项目中。
4. 编写Java程序，使用JavaMail API和JAF库来发送电子邮件。

## 3.依懒包

```xml
        <!-- https://mvnrepository.com/artifact/jakarta.mail/jakarta.mail-api -->
        <dependency>
            <groupId>jakarta.mail</groupId>
            <artifactId>jakarta.mail-api</artifactId>
            <version>2.1.2</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.sun.mail/jakarta.mail -->
        <dependency>
            <groupId>com.sun.mail</groupId>
            <artifactId>jakarta.mail</artifactId>
            <version>2.0.1</version>
        </dependency>
```

## 4.示例 发送验证码

```java
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;

public class EmailSender {
    private final static String senderEmail = "你的QQ邮箱地址";
    private final static String senderPassword = "你的授权码";
    private final static String emailSMTPHostName = "smtp.qq.com"; //smtp.163.com
    private final static String emailServerPort = "465";
    private final static String receiverEmail = "接收验证码的邮箱地址";

    public static String generateCaptcha() {    
        int length = 6; // 验证码长度
        String numbers = "0123456789"; // 数字范围
        Random random = new Random();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            int index = random.nextInt(numbers.length());
            char digit = numbers.charAt(index);
            sb.append(digit);
        }
        return sb.toString(); // 返回生成的验证码
    }

    public static void sendEmail(String message) {
        try {    
            Properties props = new Properties();

            // 初始化邮件服务
            props.put("mail.smtp.auth", "true");
            props.put("mail.smtp.ssl.enable", "true");
            props.put("mail.smtp.host", emailSMTPHostName);
            props.put("mail.smtp.port", emailServerPort);

            Session session = Session.getInstance(props,
                new javax.mail.Authenticator() {
                    protected PasswordAuthentication getPasswordAuthentication() {
                        return new PasswordAuthentication(senderEmail, senderPassword);
                    }
                });

            // 创建邮件消息体
            Message msg = new MimeMessage(session);
            msg.setFrom(new InternetAddress(senderEmail));
            msg.setRecipient(Message.RecipientType.TO, new InternetAddress(receiverEmail));
            msg.setSubject("验证码");
            msg.setText(message);

            // 发送邮件
            Transport.send(msg);
            System.out.println("验证码已发送到您的邮箱，请查收！");
        } catch (MessagingException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        String captcha = generateCaptcha(); // 生成验证码
        sendEmail("您的验证码为：" + captcha); // 发送验证码邮件
    }
}
```

# 60.加密

## 1.MD5普通加密

可使用**Apache**的一个MD5加密工具**DigestUtils**进行加密，具体操作如下：

```java
   String s1 = DigestUtils.md5Hex("123456");
```

容易破解

## 2.MD5盐值加密使用

### 2.1、Md5Crypt加密

Md5Crypt可以自定义盐值加密也可以使用默认的盐值加密

1、默认盐值加密

```java
String s1 = Md5Crypt.md5Crypt("123456".getBytes());
```

2.自定义盐值加密

```java
String s1 = Md5Crypt.md5Crypt("123456".getBytes(),"$1$22222222");
```

### 2.2使用spring提供的工具 BCryptPasswordEncoder（推荐）

导入依赖

```
<!--Spring Security-->
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-security</artifactId>
</dependency>

```

使用spring提供的工具 **BCryptPasswordEncoder**来进行**MD5盐值加密**

```java

        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
String encode1 = passwordEncoder.encode("123456");
```

# 61.第三方登录

## 1.gitee

**今天我们来学习：码云（Gitee）授权第三方登录，相比之前 [支付宝登录](https://blog.csdn.net/qq_40065776/article/details/104979271)、[腾讯QQ登录](https://blog.csdn.net/qq_40065776/article/details/104497177) 以及 [新浪微博登录](https://blog.csdn.net/qq_40065776/article/details/104583624) 来说，相对于比较简单**

### 一、准备工作

*   1、登录 [码云官网](https://gitee.com/)

```java
官网地址：https://gitee.com/

```

注册、登录我们的账号

*   2、创建应用  
    ![](https://yqlyq.github.io/problemImages/imgs202306072057922.png)
    
    在右上角菜单找到 “设置” 选项  
    ![](https://yqlyq.github.io/problemImages/imgs202306072057368.png)
    
    在 “安全设置” 下找到 “第三方应用”  
    ![](https://yqlyq.github.io/problemImages/imgs202306072057428.png)
    
    点击 “创建应用” 开始创建第三方应用  
    ![](https://yqlyq.github.io/problemImages/imgs202306072057933.png)
    
    按照要求填写应用信息即可  
    ![](https://yqlyq.github.io/problemImages/imgs202306072057359.png)
    
*   3、将应用信息保存到项目中  
    ![](https://yqlyq.github.io/problemImages/imgs202306072057736.png)
    
    由于我使用的是 SpringBoot 项目，我放在了 application.yml 文件中

### 二、开始开发

*   1、引入 Maven 依赖

```java
<!-- 网络请求 -->
<dependency>
	<groupId>org.apache.httpcomponents</groupId>
	<artifactId>httpclient</artifactId>
	<version>4.5.6</version>
</dependency>
<!-- alibaba的fastjson -->
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>fastjson</artifactId>
	<version>1.2.51</version>
</dependency>

```

其余的依赖请自行加入

*   2、在页面放置 “码云（Gitee）” 授权登录的 DOM 元素

```java
<a th:href="@{gitee/auth}" class="link" title="Gitee登录"><i class="iconfont icon-gitee"></i></a>

```

这里使用的是阿里的 iconfont 图标

### 三、接口类

创建 “码云（[Gitee](https://so.csdn.net/so/search?q=Gitee&spm=1001.2101.3001.7020)）” 授权登录的 Controller，GiteeController.java

*   1、从配置文件中获取 “码云（Gitee）” 配置信息

```java
/**
 * gitee授权中提供的 appid 和 appkey
 */
@Value("${gitee.oauth.clientid}")
public String CLIENTID;
@Value("${gitee.oauth.clientsecret}")
public String CLIENTSECRET;
@Value("${gitee.oauth.callback}")
public String URL;

```

*   2、页面登录按钮点击后的接口

```java
/**
 * 请求授权页面
 */
@GetMapping(value = "/auth")
public String qqAuth(HttpSession session) {
    // 用于第三方应用防止CSRF攻击
    String uuid = UUID.randomUUID().toString().replaceAll("-", "");
    session.setAttribute("state", uuid);

    // Step1：获取Authorization Code
    String url = "https://gitee.com/oauth/authorize?response_type=code" +
            "&client_id=" + CLIENTID +
            "&redirect_uri=" + URLEncoder.encode(URL) +
            "&state=" + uuid +
            "&scope=user_info";

    return PasswordUtils.redirectTo(url);
}

```

接口文档中建议我们在授权登录时传入一个加密的数据防止被攻击，我们传入了UUID，最后重定向到授权页面  
![](https://yqlyq.github.io/problemImages/imgs202306072058623.png)

*   3、当该用户点击“授权”按钮，同意授权后，就会回调到我们在应用中填写的回调地址里去

```java
/**
 * 授权回调
 */
@GetMapping(value = "/callback")
public String qqCallback(HttpServletRequest request) throws Exception {
    HttpSession session = request.getSession();
    // 得到Authorization Code
    String code = request.getParameter("code");
    // 我们放在地址中的状态码
    String state = request.getParameter("state");
    String uuid = (String) session.getAttribute("state");

    // 验证信息我们发送的状态码
    if (null != uuid) {
        // 状态码不正确，直接返回登录页面
        if (!uuid.equals(state)) {
            return PasswordUtils.redirectTo("/login");
        }
    }

    // Step2：通过Authorization Code获取Access Token
    String url = "https://gitee.com/oauth/token?grant_type=authorization_code" +
            "&client_id=" + CLIENTID +
            "&client_secret=" + CLIENTSECRET +
            "&code=" + code +
            "&redirect_uri=" + URL;
    JSONObject accessTokenJson = GiteeHttpClient.getAccessToken(url);

    // Step3: 获取用户信息
    url = "https://gitee.com/api/v5/user?access_token=" + accessTokenJson.get("access_token");
    JSONObject jsonObject = GiteeHttpClient.getUserInfo(url);
    /**
     * 获取到用户信息之后，就该写你自己的业务逻辑了
     */
    return PasswordUtils.redirectTo("/success");
}

```

### 四、网络请求方法

上面回调方法中所用到的网络接口方法，我放在了 GiteeHttpClient.java 文件中，主要有两个方法

*   1、网络接口

```java
/**
 * 获取Access Token
 * post
 */
public static JSONObject getAccessToken(String url) throws IOException {
    HttpClient client = HttpClients.createDefault();
    HttpPost httpPost = new HttpPost(url);
    httpPost.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36");
    HttpResponse response = client.execute(httpPost);
    HttpEntity entity = response.getEntity();
    if (null != entity) {
        String result = EntityUtils.toString(entity, "UTF-8");
        return JSONObject.parseObject(result);
    }
    httpPost.releaseConnection();
    return null;
}

/**
 * 获取用户信息
 * get
 */
public static JSONObject getUserInfo(String url) throws IOException {
    JSONObject jsonObject = null;
    CloseableHttpClient client = HttpClients.createDefault();

    HttpGet httpGet = new HttpGet(url);
    httpGet.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36");
    HttpResponse response = client.execute(httpGet);
    HttpEntity entity = response.getEntity();

    if (entity != null) {
        String result = EntityUtils.toString(entity, "UTF-8");
        jsonObject = JSONObject.parseObject(result);
    }

    httpGet.releaseConnection();

    return jsonObject;
}

```

分别就是使用 code 获取 token，在使用 token 获取 用户信息

**注意：** 我们需要在请求时加上请求头

```java
User-Agent Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36

```

最终我们获取到一个 JSON 对象，该对象包含了用户的信息，例如：id，name，email，phone 等等。

*   2、官方 [OAuth 文档](https://gitee.com/api/v5/oauth_doc#/)

```java
https://gitee.com/api/v5/oauth_doc#/

```

### 五、总结

该授权认证过程符合 OAuth2 认证基本流程，流程如下：  
![](https://yqlyq.github.io/problemImages/imgs202306072058831.png)

> 1、用户点击页面登录按钮，请求授权页面，用户在此页面登录账号并同意授权  
> 2、用户同意授权后，回调至我们项目中，首先验证 state 是否一致  
> 3、使用上一步拿到的 code 请求 access_token  
> 4、使用 access_token 请求 用户信息，完成授权登录过程




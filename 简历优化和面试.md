项目名称：谷粒商城
=====

*   书阁”图书商城管理系统、微盟电子商城网络交易系统、高校闲置资源交易系统
*   购物在“e”零售商城平台、惠农通—智慧农资商城 、农产品轻量级微商城系统

项目简介：
-----

*   本系统采用微服务架构设计,在分布式环境下利用Spring Cloud框架,通过业务划分,设计独立模块的微服务，拆分为订单服务、购物车服务、支付服务、用户管理服务、商品管理服务、文件上传服务等模块，结合了当前比较流行的互联网电商模式,为消费者提供商品贸易平台。

系统架构：
-----

*   该系用采用SpringCloud架构，利用SpringBoot构建应用，Nacos作为服务的注册、配置中心，OpenFeign实现与其他模块进行交互，Sentinel实现熔断降级和错误处理，Seata分布式事务解决方案，Gateway作为服务网关，Sleuth链路追踪，RabbitMQ实现延迟队列，Redis作为缓存解决读多写少的场景，MySQL进行持久化，MyBatisPlus作为持久化框架。

我的职责:
-----

*   完成平台**商品、购物车、订单、库存、优惠券、支付、文件上传**等服务模块的接口开发；
*   使用**RabbitMQ延时队列**实现未付款订单，超过一定时间后，**系统自动取消订单并解锁库存；**
*   使用**redis+lua脚本**防止重复提交攻击，**解决了用户利用浏览器刷新和回退重复提交订单的问题；**
*   基于**Redisson分布式限流：Semaphore信号量**实现**秒杀和一人一单功能**，通过逐步**改进分布式锁**的方案，**解决在多线程情况下用户重复提交订单的幂等性问题；**
*   基于 **Token** 的认证授权机制：**JWT**，通过对登录用户颁发登录凭证，**实现登录模块认证授权功能；**
*   使用**ElasticSearch分布式全文搜索引擎**，对冷数据，商品信息数据**建立索引**，**保证冷数据，商品数据的查询性能；**
*   利用**Jmeter工具**进行压测，找到在**多线程**情况下造成的**内存泄漏，并发与同步**等问题，**保证了系统在线上的处理能力和稳定性维持在一个标准范围内；**
*   使用**Redis**进行**热点信息缓存**，比如附近购物车信息和登录信息,**提高服务器的性能**；
*   使用**Spring Schedule定时任务**提前上架抢购商品信息到Redis缓存中实现**库存预热功能**
*   使用**Redisson分布式锁**解决分布式系统下商品重复上架的**幂等性问题**；
*   使用**Spring Cache方法级别缓存技术**，实现已经被调用过的指定的目标方法，直接从缓存中获取方法调用后的结果返回，**提高系统的响应速度；**
*   使用**CompletableFuture 异步编排**解决查询商品详情⻚**响应速度慢的问题**；
*   使用**Nacos作为注册中心与配置中心**，将服务名称及其对应地址进行存储，实现服务地址的**注册与发现**以及**配置动态加载**等功能
*   使用**Seata中的TCC事务模式**，把一个完整的业务逻辑拆分成三个阶段,通过事务管理器进行管理，**保证分布式系统数据一致性问题；**
*   整合**第三方文件上传服务**，如阿里云对象存储，基于服务端签名后直传，**保证文件传输的安全性**；
*   整合**OAuth2.0协议授权**，使用AccessToken调用开发API获取用户信息，**支持微信、QQ、微博、Gitee、Github等第三方登陆；**
*   使用**RSA算法保证数据加密安全**，成功对接第三方支付功能，订单付款支持**支付宝、微信支付**等第三方支付服务。

核心业务：
-----

### 商品上架

*   上架的商品才可以在网站展示。

### 商品检索

*   商品检索三个入口：
    *   选择分类进入商品检索
    *   输入检索关键字展示检索页
    *   选择筛选条件进入

### 商品详情

1.  获取sku的基本信息 0.5s
2.  获取sku的图片信息 0.5s
3.  获取sku的促销信息 1s
4.  获取spu的所有销售属性1s
5.  获取规格参数组及组下的规格参数 1.5s
6.  spu详情 1s

### 购物车

*   **核心业务：** 
    
    *   用户可以使用购物车一起结算下单
        
    *   给购物车 添加商品
        
    *   用户可以 查询自己的购物车
        
    *   用户可以在购物车中 修改购买商品的数量。
        
    *   用户可以在购物车中 删除商品。
        
    *   选中不选中商品
        
    *   在购物车中展示商品优惠信息
        
    *   提示购物车商品价格变化
    
*   **购物车Redis数据结构选型：** 
    
    *   Redis 有 5 种不同数据结构，这里选择哪一种比较合适呢？Map<String, List>
        
        *   首先不同用户应该有独立的购物车，因此购物车应该以用户的作为 key 来存储，Value 是  
            用户的所有购物车信息。这样看来基本的`k-v`结构就可以了。
            
        *   但是，我们对购物车中的商品进行增、删、改操作，基本都需要根据商品 id 进行判断，  
            为了方便后期处理，我们的购物车也应该是`k-v`结构，key 是商品 id，value 才是这个商品的  
            购物车信息。
            
        *   综上所述，我们的购物车结构是一个**双层 Map：Map<String,Map<String,String>>**
            
            *   第一层 Map，Key 是用户 id
                
            *   第二层 Map，Key 是购物车中商品 id，值是购物项数据
    
*   **购物车两个核心功能：新增商品到购物车、查询购物车**
    
    *   **新增商品：判断是否登录**
        
        *   是：则添加商品到后台 Redis 中，把 user 的唯一标识符作为 key。
            
        *   否：则添加商品到后台 redis 中，使用随机生成的 user-key 作为 key。
        
    *   **查询购物车列表：判断是否登录**
        
        *   否：直接根据 user-key 查询 redis 中数据并展示
            
        *   是：已登录，则需要先根据 user-key 查询 redis 是否有数据。
            
        *   有：需要提交到后台添加到 redis，合并数据，而后查询。
            
        *   否：直接去后台查询 redis，而后返回
            

### 订单

#### 订单中心

*   电商系统涉及到 3 流，分别时信息流，资金流，物流，而订单系统作为中枢将三者有机的集  
    合起来。
*   订单模块是电商系统的枢纽，在订单这个环节上需求获取多个模块的数据和信息，同时对这  
    些信息进行加工处理后流向下个环节，这一系列就构成了订单的信息流通。

#### 订单构成

![](https://img-blog.csdnimg.cn/c5c72178d2e14fd7b421ea6888530388.png#pic_center)

#### 订单状态

1.  **待付款**
    *   用户提交订单后，订单进行预下单，目前主流电商网站都会唤起支付，便于用户快速完成支  
        付，需要注意的是待付款状态下可以对库存进行锁定，锁定库存需要配置支付超时时间，超  
        时后将自动取消订单，订单变更关闭状态。
2.  **已付款/ 待发货**
    *   用户完成订单支付，订单系统需要记录支付时间，支付流水单号便于对账，订单下放到 WMS  
        系统，仓库进行调拨，配货，分拣，出库等操作。
3.  **待收货/ 已发货**
    *   仓储将商品出库后，订单进入物流环节，订单系统需要同步物流信息，便于用户实时知悉物  
        品物流状态
4.  **已完成**
    *   用户确认收货后，订单交易完成。后续支付侧进行结算，如果订单存在问题进入售后状态
5.  **已取消**
    *   付款之前取消订单。包括超时未付款或用户商户取消订单都会产生这种订单状态。

#### 订单流程

*   正常的网购步骤：订单生成–>支付订单–>卖家发货–>确认收货–>交易成功

1.  订单创建与支付
2.  订单创建前需要预览订单，选择收货信息等
3.  订单创建需要锁定库存，库存有才可创建，否则不能创建
4.  订单创建后超时未支付需要解锁库存
5.  支付成功后，需要进行拆单，根据商品打包方式，所在仓库，物流等进行拆单
6.  支付的每笔流水都需要记录，以待查账
7.  订单创建，支付成功等状态都需要给 MQ 发送消息，方便其他系统感知订阅

**防止超卖** : 数据库 unsigned int 做最后的保证。 (范围0~65535)

**自动关单**：订单超时未支付，需要取消订单 ([MQ](https://so.csdn.net/so/search?q=MQ&spm=1001.2101.3001.7020))

**解锁库存**: (MQ)

*   订单关闭，需要解锁已经占用的库存
*   库存锁定成功，订单回滚，保证最终一致性，也需要库存自动解锁

#### 订单确认页流程

![](https://img-blog.csdnimg.cn/398834edbb5643cf986fdd87f7163e8c.png#pic_center)

#### 电商订单流程图

![](https://img-blog.csdnimg.cn/34744841a994422a96febe8fa3d9e8aa.png#pic_center)

### [秒杀](https://so.csdn.net/so/search?q=%E7%A7%92%E6%9D%80&spm=1001.2101.3001.7020)

*   秒杀业务
    
    *   秒杀具有瞬间高并发的特点，针对这一特点，必须要做限流 \+ 异步 \+ 缓存（页面静态化）\+ 独立部署。
    *   限流方式：
        *   前端限流，一些高并发的网站直接在前端页面开始限流，例如：小米的验证码设计
        *   nginx 限流，直接负载部分请求到错误的静态页面：令牌算法 漏斗算法
        *   网关限流，限流的过滤器
        *   代码中使用分布式信号量
        *   rabbitmq 限流（能者多劳：chanel.basicQos(1)），保证发挥所有服务器的性能。
*   秒杀流程
    
*   限流
    
    *   参照 Alibaba Sentinel

CompletableFuture异步编排
---------------------

### 概念

*   CompletableFuture是JDK1.8里面引入的一个异步回调类，就是说当前使用异步线程去执行一个任务时候，我们希望在这个任务结束以后，触发一个后续的动作，而CompletableFuture就可以实现这样的功能。

```
举个简单的例子：在一个批量支付的业务逻辑里面，涉及到查询订单，支付和发送邮件通知这三个逻辑，那么这三个逻辑是按照顺序，同步去实现的，也就是说先查询订单，查询到以后再针对这个订单发起支付，支付成功以后再发送邮件通知，而这种设计方式会导致这个方法的执行效率会比较慢。

```

![](https://img-blog.csdnimg.cn/9bb7340598614fabb424bd2d986b4790.png#pic_center)

```
所以，在这里我们可以直接使用CompletableFuture，也就是说我们可以把查询到订单的逻辑，放在一个异步线程里面去处理，然后基于CompletableFuture 一个事件回调机制，我们可以配置查询订单，结束之后的一个触发支付的一个动作，支付结束之后再自动触发邮件通知，从而极大的去提升这个业务场景的处理性能。

```

*   CompletableFuture提供了5种不同方式，把多个异步任务组成一个具有先后关系的任务链，然后基于事件来驱动任务链的一个执行。  
    ![](https://img-blog.csdnimg.cn/671d59b96247418b8cbf53e48f856afb.png#pic_center)
    
*   第一种是thenCombine, 把2个任务组合在一起，当2个任务都执行结束以后，触发某个事件的回调，
    

![](https://img-blog.csdnimg.cn/e2dce5b3dccb4b7ebbd7eb6c181dd1cc.png#pic_center)

*   第二种是thenCompose,它同样是把2个任务组合在一起，那么这2个任务是串行执行的，也就是说第一个任务执行结束以后，自动去触发执行第二个任务，

![](https://img-blog.csdnimg.cn/db2ee20150964237b4877344ba023976.png#pic_center)

*   第三种thenAccept，它是第一个任务执行结束以后，触发第二个任务，并且第一个任务的执行结果，作为第二个任务的一个参数，这个方法是纯粹的接受上一个任务的执行结果，不返回任何新的计算值。

![](https://img-blog.csdnimg.cn/4918e177cb2f4d6aa885dea826c61b84.png#pic_center)

*   第四种是thenApply和thenAccept一样，它是一种具有返回值的一个方法；

![](https://img-blog.csdnimg.cn/3377c26c3ec240edbde12b971b021cc1.png#pic_center)

*   第五种是thenRun,就是说第一个任务执行完成以后，触发执行一个实现Runnable接口的一个任务，

![](https://img-blog.csdnimg.cn/5da591a5943d41cb8c4ee293c2ded490.png#pic_center)

*   最后我认为CompletableFuture，弥补了原本Future的一个不足，使得程序可以在非阻塞的状态下，去完成异步的一个回调机制。

### 业务场景

*   查询商品详情页的逻辑比较复杂，有些数据还需要远程调用，必然需要花费更多的时间。

![](https://img-blog.csdnimg.cn/61275a47765d4a0b941b43b8ea7bb3e3.png#pic_center)

*   假如商品详情页的每个查询，需要如下标注的时间才能完成  
    那么，用户需要 5.5s 后才能看到商品详情页的内容。很显然是不能接受的。  
    如果有多个线程同时完成这 6 步操作，也许只需要 1.5s 即可完成响应。
    
*   在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的  
    Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以  
    通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。
    

### 项目代码

SkuInfoServiceImpl

```
 `@Override
    public SkuItemVo item(Long skuId) throws ExecutionException, InterruptedException {
        SkuItemVo skuItemVo = new SkuItemVo();
        
        
        CompletableFuture<SkuInfoEntity> infoFuture = CompletableFuture.supplyAsync(() -> {
            
            SkuInfoEntity info = this.getById(skuId);
            skuItemVo.setInfo(info);
            return info;
        }, executor);

        
        
        CompletableFuture<Void> saleAttrFuture = infoFuture.thenAcceptAsync((res) -> {
            
            List<SkuItemSaleAttrVo> saleAttrVos = skuSaleAttrValueService.getSaleAttrBySpuId(res.getSpuId());
            skuItemVo.setSaleAttr(saleAttrVos);
        }, executor);

        CompletableFuture<Void> descFuture = infoFuture.thenAcceptAsync((res) -> {
            
            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescService.getById(res.getSpuId());
            skuItemVo.setDesc(spuInfoDescEntity);
        }, executor);

        CompletableFuture<Void> baseAttrFuture = infoFuture.thenAcceptAsync((res) -> {
            
            List<SpuItemAttrGroupVo> attrGroupVos = attrGroupService.getAttrGroupWithAttrsBySpuId(res.getSpuId(), res.getCatalogId());
            skuItemVo.setGroupAttrs(attrGroupVos);
        }, executor);

        
        
        
        CompletableFuture<Void> imageFuture = CompletableFuture.runAsync(() -> {
            List<SkuImagesEntity> imagesEntities = skuImagesService.getImagesBySkuId(skuId);
            skuItemVo.setImages(imagesEntities);
        }, executor);

        
        CompletableFuture<Void> seckillFuture = CompletableFuture.runAsync(() -> {
            
            R skuSeckilInfo = seckillFeignService.getSkuSeckilInfo(skuId);
            if (skuSeckilInfo.getCode() == 0) {
                
                SeckillSkuVo skuSeckilInfoData = skuSeckilInfo.getData("data", new TypeReference<SeckillSkuVo>() {
                });
                skuItemVo.setSeckillSkuVo(skuSeckilInfoData);

                if (skuSeckilInfoData != null) {
                    long currentTime = System.currentTimeMillis();
                    if (currentTime > skuSeckilInfoData.getEndTime()) {
                        skuItemVo.setSeckillSkuVo(null);
                    }
                }
            }
        }, executor);

        
        
        
        CompletableFuture.allOf(saleAttrFuture,descFuture,baseAttrFuture,imageFuture,seckillFuture).get();
        return skuItemVo;
    }` 

![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)

*   1
*   2
*   3
*   4
*   5
*   6
*   7
*   8
*   9
*   10
*   11
*   12
*   13
*   14
*   15
*   16
*   17
*   18
*   19
*   20
*   21
*   22
*   23
*   24
*   25
*   26
*   27
*   28
*   29
*   30
*   31
*   32
*   33
*   34
*   35
*   36
*   37
*   38
*   39
*   40
*   41
*   42
*   43
*   44
*   45
*   46
*   47
*   48
*   49
*   50
*   51
*   52
*   53
*   54
*   55
*   56
*   57
*   58
*   59
*   60
*   61
*   62
*   63
*   64
*   65
*   66
*   67
*   68
*   69
*   70
*   71
*   72
*   73
*   74
*   75
*   76
*   77
*   78
*   79
*   80
*   81
*   82


```

RabbitMQ延时队列（实现定时任务）
--------------------

### 场景：

*   比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。
    
*   常用解决方案：spring的 schedule 定时任务轮询数据库
    
    *   缺点：消耗系统内存、增加了数据库的压力、存在较大的时间误差
*   解决：rabbitmq的消息TTL和死信Exchange结合
    

### 消息的TTL（Time To Live）

*   消息的TTL就是消息的存活时间。
*   RabbitMQ可以对队列和消息分别设置TTL。
*   对队列设置就是队列没有消费者连着的保留时间，**也可以对每一个单独的消息做单独的**  
    **设置。超过了这个时间，我们认为这个消息就死了，称之为死信**。
*   如果队列设置了，消息也设置了，那么会**取小的**。所以一个消息如果被路由到不同的队  
    列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的  
    TTL，因为它才是实现延迟任务的关键。可以通过**设置消息的expiration字段或者x-**  
    **message-ttl属性来设置时间**，两者是一样的效果。

### Dead Letter Exchanges（DLX）

*   一个消息在满足如下条件下，会进**死信路由**，记住这里是路由而不是队列，  
    一个路由可以对应很多队列。（什么是死信）
    *   一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不  
        会被再次放在队列里，被其他消费者使用。 （ basic.reject/ basic.nack ） requeue=false
    *   上面的消息的TTL到了，消息过期了。
    *   队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上
*   Dead Letter Exchange其实就是一种普通的exchange，和创建其他  
    exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有  
    消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。
*   我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息  
    被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列
*   手动ack&异常消息统一放在一个队列处理建议的两种方式
*   catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费
*   给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败

### 延时队列实现

*   给队列设置过期时间

![](https://img-blog.csdnimg.cn/14d96ab921a04074ac111cc011e2166c.png#pic_center)

*   给消息设置过期时间

![](https://img-blog.csdnimg.cn/135097c8bb0b4a7b846a3285f0c2836f.png#pic_center)

*   推荐：给队列设置过期时间，因为给消息设置过期时间的话，RabbitMQ采用的是惰性检查机制，假设队列里面的消息过期时间不同，后面的消息必须等前面的消息过期，最终导致消息不能按照规定的过期时间过期。

### SpringBoot中使用延时队列

1、Queue、Exchange、Binding可以@Bean进去  
2、监听消息的方法可以有三种参数（不分数量，顺序）  
Object content, Message message, Channel channel  
3、channel可以用来拒绝消息，否则自动ack；

### 消息队列流程

*   使用RabbitMQ延时队列实现未付款订单，超过一定时间后，系统自动取消订单并解锁库存。
*   PS:创建订单 进入路由键-order.create.order- 进入交换机order-event-exchange， 根据路由键会转发到延时队列order.delay.queue 1min过期时间，过期时间到了之后，根据路由键order.release.order-到达释放订单队列order.release.order.queue， 监听这个队列的方法 先是判断订单是不是已支付，如果不是 就关闭订单，关闭订单之后，根据路由键order.release.other 发送关闭的订单数据到交换机order-event-exchange，交换机再转发到order.release.coupon.queue优惠券队列，返回优惠券，与之通过 也是根据路由键order.release.other，和数据一起转发到解锁库存队列stock.release.stock.queue 解锁库存。

![](https://img-blog.csdnimg.cn/a7bc537a77274adb8ebf5f077290a8e7.jpeg#pic_center)

Spring Schedule定时任务
-------------------

*   语法：秒 分 时 日 月 周 年（Spring 不支持）

```
 `@Async
     @Scheduled(cron = "*/5 * * ? * 4")
     public void hello() {
         log.info("hello...");
         try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }

     }` 

![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)

*   1
*   2
*   3
*   4
*   5
*   6
*   7
*   8
*   9
*   10
*   11
*   12
*   13
*   14
*   15
*   16
*   17
*   18
*   19
*   20
*   21
*   22
*   23
*   24
*   25
*   26
*   27
*   28
*   29
*   30
*   31
*   32
*   33
*   34
*   35
*   36


```

Redis实现库存预热
-----------

*   使用 Spring Schedule定时任务提前上架抢购商品信息到Redis缓存中实现库存预热功能,同时使用Redisson分布式锁保证在分布式系统下商品上架的幂等性；

```
SeckillServiceImpl

```

```
`public void uploadSeckillSkuLatest3Days() {
    
    R lates3DaySession = couponFeignService.getLates3DaySession();
    if (lates3DaySession.getCode() == 0){
        
        List<SeckillSessionWithSkusVo> sessionData = lates3DaySession.getData("data", new TypeReference<List<SeckillSessionWithSkusVo>>() {
        });
        
        
        saveSessionInfos(sessionData);

        
        saveSessionSkuInfo(sessionData);

    }
}` 

![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)

*   1
*   2
*   3
*   4
*   5
*   6
*   7
*   8
*   9
*   10
*   11
*   12
*   13
*   14
*   15
*   16


```

#### 缓存秒杀活动信息

```
 `private void saveSessionInfos(List<SeckillSessionWithSkusVo> sessions) {
    if(sessions != null){
        sessions.stream().forEach(session -> {

            
            long startTime = session.getStartTime().getTime();
            long endTime = session.getEndTime().getTime();

            
            String key = SESSION__CACHE_PREFIX + startTime + "_" + endTime;

            
            Boolean hasKey = redisTemplate.hasKey(key);
            
            if (!hasKey) {
                
                List<String> skuIds = session.getRelationSkus().stream()
                        .map(item -> item.getPromotionSessionId() + "-" + item.getSkuId().toString()).collect(Collectors.toList());
                redisTemplate.opsForList().leftPushAll(key,skuIds);
            }
        });
    }

}` 

![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)

*   1
*   2
*   3
*   4
*   5
*   6
*   7
*   8
*   9
*   10
*   11
*   12
*   13
*   14
*   15
*   16
*   17
*   18
*   19
*   20
*   21
*   22
*   23
*   24
*   25
*   26
*   27
*   28
*   29


```

#### 缓存秒杀活动所关联的商品信息

```
 `private void saveSessionSkuInfo(List<SeckillSessionWithSkusVo> sessions) {
    if (sessions != null){
        sessions.stream().forEach(session -> {
            
            BoundHashOperations<String, Object, Object> operations = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);
            session.getRelationSkus().stream().forEach(seckillSkuVo -> {
                
                String token = UUID.randomUUID().toString().replace("-", "");
                String redisKey = seckillSkuVo.getPromotionSessionId().toString() + "-" + seckillSkuVo.getSkuId().toString();
                if (!operations.hasKey(redisKey)) {

                    
                    SeckillSkuRedisTo redisTo = new SeckillSkuRedisTo();
                    Long skuId = seckillSkuVo.getSkuId();
                    
                    R info = productFeignService.getSkuInfo(skuId);
                    if (info.getCode() == 0) {
                        SkuInfoVo skuInfo = info.getData("skuInfo",new TypeReference<SkuInfoVo>(){});
                        redisTo.setSkuInfo(skuInfo);
                    }

                    
                    BeanUtils.copyProperties(seckillSkuVo,redisTo);

                    
                    redisTo.setStartTime(session.getStartTime().getTime());
                    redisTo.setEndTime(session.getEndTime().getTime());

                    
                    redisTo.setRandomCode(token);

                    
                    String seckillValue = JSON.toJSONString(redisTo);
                    operations.put(seckillSkuVo.getPromotionSessionId().toString() + "-" + seckillSkuVo.getSkuId().toString(),seckillValue);

                    
                    
                    
                    RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);
                    
                    semaphore.trySetPermits(seckillSkuVo.getSeckillCount());
                }
            });
        });
    }

}` 

![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)

*   1
*   2
*   3
*   4
*   5
*   6
*   7
*   8
*   9
*   10
*   11
*   12
*   13
*   14
*   15
*   16
*   17
*   18
*   19
*   20
*   21
*   22
*   23
*   24
*   25
*   26
*   27
*   28
*   29
*   30
*   31
*   32
*   33
*   34
*   35
*   36
*   37
*   38
*   39
*   40
*   41
*   42
*   43
*   44
*   45
*   46
*   47
*   48
*   49
*   50
*   51


```

Redis缓存中的数据结构
-------------

### 分类菜单

*   类型：String
*   value: 菜单信息

### 登陆信息-SpringSession

### 购物车

*   类型：Hash
*   key: gulimall:cart:2 // 2为用户ID
*   field: 商品 id
*   value: 购物项数据
*   综上所述，我们的购物车结构是一个双层 Map：Map<String,Map<String,String>>
    *   第一层 Map，Key 是用户 id
    *   第二层 Map，Key 是购物车中商品 id，值是购物项数据

### 秒杀上架 (幂等性处理)

*   缓存秒杀活动信息 (seckill:session:)
    *   类型: List
    *   key: seckill:session:start\_endtime // 开始时间的时间戳\_结束时间的时间戳
    *   value: 场次ID_商品ID
*   缓存秒杀活动所关联的商品信息 (seckill:skus)
    *   类型：Hash
    *   key: seckill:skus
    *   field: 场次ID_商品ID
    *   value: 秒杀商品信息
*   秒杀库存信号量
    *   类型： String
    *   key: seckIll:stock:UUID
    *   value: 库存数量

### 幂等性保证

*   缓存商品信息前，先判断有没有这个key

```java
    String redisKey = seckillSkuVo.getPromotionSessionId().toString() + "-" + seckillSkuVo.getSkuId().toString();
            if (!operations.hasKey(redisKey)) {

```

```java
              
                Boolean hasKey = redisTemplate.hasKey(key);
                
                if (!hasKey) {

```

### Redission分布式锁

*   设置分布式锁以及信号量-关键代码

```java
    
    private final String upload_lock = "seckill:upload:lock";
    
  
        RLock lock = redissonClient.getLock(upload_lock);
        try {
            
            lock.lock(10, TimeUnit.SECONDS);
            seckillService.uploadSeckillSkuLatest3Days();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

```

```java
          
                        
                        
                        RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);
                        
                        semaphore.trySetPermits(seckillSkuVo.getSeckillCount());

```

分布式事务
-----

### 事务的坑

*   在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。原因是没有用到代理对象的缘故。
*   解决：
    *   0）、导入 spring-boot-starter-aop
    *   1）、@EnableTransactionManagement(proxyTargetClass = true)
    *   2）、@EnableAspectJAutoProxy(exposeProxy=true)
    *   3）、AopContext.currentProxy() 调用方法

### CAP理论

*   C是**一致性**，分布式系统的**数据要保持一致**
*   A是**可用性**，分布式系统能进行**故障转移**
*   P是**分区容错性**，分布式系统**出现网络问题能正常运行**
*   CAP理论是指分布式系统中不能保证三者同时存在，只能两两组合

### BASE 理论

*   是对 CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可 以采用适当的采取弱一致性，即**最终一致性。** 

### 分布式事务几种方案

*   2PC 模式
    
    *   数据库支持的 2PC【2 phase commit 二阶提交】，又叫做 XA Transactions。
        *   第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是 否可以提交.
        *   第二阶段：事务协调器要求每个数据库提交数据。
    *   **性能不理想**
*   柔性事务-TCC 事务补偿型方案
    
    *   一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。
    *   二阶段 commit 行为：调用 自定义 的 commit 逻辑。
    *   二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。
    *   所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中
*   柔性事务-最大努力通知型方案
    
    *   按规律进行通知，**不保证数据一定能通知成功，但会提供可查询操作接口进行核对**。
    *   这种 方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。
    *   这种 方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。
*   柔性事务-**可靠消息**+最终一致性方案（异步确保型）
    
    *   实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只 记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确 认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。
    *   防止消息丢失：
        *   1、做好消息确认机制（pulisher，consumer【手动 ack】）
        *   2、每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一 遍

> 刚性事务：遵循 ACID 原则，强一致性。
>
> 柔性事务：遵循 BASE 理论，最终一致性；
>
> 与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。

Seata
-----

[Seata 是什么](https://seata.io/zh-cn/docs/overview/what-is-seata.html)

### Seata的理解

*   Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
    *   AT模式。是一种基于**本地事务+二阶段协议**来实现的**最终数据一致性方案**，也是Seata默认的解决方案。
    *   TCC模式，TCC事务是Try,Confirm,Cancel 三个词语的缩写，简单理解就是把**一个完整的业务逻辑拆分成三个阶段**，然后通过事务管理器在业务逻辑层面，根据每个分支事务的执行情况分别调用该业务的Confirm 或者Cacel方法。
    *   Saga模式，Saga模式是SEATA提供**长事务解决方案**，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者。
    *   XA模式，XA可以认为是一种**强一致性的事务解决方法**，它利用事务资源（数据库，消息服务等）对XA协议的支持，以XA协议的机制来管理分支事务的一种事务模式。

> [Seata 是什么](https://seata.io/zh-cn/docs/overview/what-is-seata.html)
>
> *   #### TC (Transaction Coordinator) - 事务协调者
>
>     *   维护全局和分支事务的状态，驱动全局事务提交或回滚。
> *   #### TM (Transaction Manager) - 事务管理器
>
>     *   定义全局事务的范围：开始全局事务、提交或回滚全局事务。
> *   #### RM (Resource Manager) - 资源管理器
>
>     *   管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。
>
> ![](https://img-blog.csdnimg.cn/e0eab506a6984314a305cb1c22dbe5c3.png#pic_center)

### Seata项目整合

*   Seata控制分布式事务
*   1）、每一个微服务先必须创建 undo_log；
*   2）、安装事务协调器；seata-server： https://github.com/seata/seata/releases
*   3）、整合
    *   1、导入依赖 spring-cloud-starter-alibaba-seata seata-all-0.7.1
    *   2、解压并启动seata-server；
        *   registry.conf: 注册中心配置； 修改registry type=nacos
        *   file.conf：
    *   3、所有想要用到分布式事务的微服务使用seata DataSourceProxy代理自己的数据源
    *   4、每个微服务，都必须导入
        *   registry.conf
        *   file.conf vgroup_mapping.{application.name}-fescar-service-group = “default”
    *   5、启动测试分布式事务
    *   6、给分布式大事务的入口标注@GlobalTransactional
    *   7、每一个远程的小事务用 @Transactional

应用场景：

*   订单服务提交订单，库存服务扣减库存
    
    *   seta-提交订单接口 OrderServiceImpl 类submitOrder（）方法 加 @GlobalTransactional
    *   （下单是高并发场景，不推荐seata分布式事务。推荐用消息队列 最终一致性）
*   商品服务保持商品信息，远程调用优惠服务保持商品优惠券信息
    
*   *   开启seta全局事务-SpuInfoServiceImpl类saveSpuInfo()方法 （推荐）

Sentinel
--------

[介绍 · alibaba/Sentinel Wiki · GitHub](https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D)

### Sentinel理解

*   随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从**流量控制、熔断降级**、系统负载保护等多个维度保护服务的稳定性。
*   我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为几个步骤:
    1.  定义资源
    2.  定义规则
    3.  检验规则是否生效
*   Sentinel 分为两个部分:
    *   核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时 对 Dubbo / Spring Cloud 等框架也有较好的支持。
    *   控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器

### 熔断降级限流

*   熔断
    *   A 服务调用 B 服务的某个功能，B服务卡死，功能时间超长，我们就将B断路，返回降级数据。
*   降级
    *   流量高峰期，服务器压力剧增，对一些页面和服务做策略的降级（停止服务，调用直接返回降级数据）
*   熔断、降级区别
    *   相同点
        *   保证服务的可用性
    *   不同点
        *   1、熔断是被调用方故障，触发的系统主动规则
        *   2、降级是基于全局考虑，停止一些正常服务，释放资源
*   限流
    *   对打入服务的请求流量进行控制，使服务能够承担不超过自己能力的流量压力

### 项目整合步骤

```
  

![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)

*   1
*   2
*   3
*   4
*   5
*   6
*   7
*   8
*   9
*   10
*   11
*   12
*   13
*   14
*   15
*   16
*   17
*   18
*   19
*   20
*   21
*   22
*   23
*   24
*   25
*   26
*   27
*   28
*   29
*   30
*   31
*   32


```

### 整合 Feign+Sentinel 测试熔断降级

*   引入依赖：>spring-cloud-starter-openfeign、spring-cloud-starter-alibaba-sentinel<
    
*   2、使用 Nacos 注册中心 spring-cloud-starter-alibaba-nacos-discovery
    
*   定义 fallbackfactory 并放在容器中
    
    *   ```java
        
        @Slf4j
        @Component
        public class SeckillFeignServiceFallBack implements SeckillFeignService {
        
            @Override
            public R getSkuSeckilInfo(Long skuId) {
                log.info("熔断方法调用..");
                return R.error(BizCodeEnum.TO_MANY_REQUEST.getCode(),BizCodeEnum.TO_MANY_REQUEST.getMessage());
            }
        }
        
        ```
    
*   6、远程接口配置 feign 客户端容错
    
    *   ```
         `@FeignClient(value = "gulimall-seckill",fallback = SeckillFeignServiceFallBack.class)
        public interface SeckillFeignService {
        
            
            @GetMapping(value = "/sku/seckill/{skuId}")
            R getSkuSeckilInfo(@PathVariable("skuId") Long skuId);
        
        }` 
        
        ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)
        
        *   1
        *   2
        *   3
        *   4
        *   5
        *   6
        *   7
        *   8
        *   9
        *   10
        *   11
        *   12
        *   13
        *   14
        *   15
        *   16
        
        
        ```
        
    *   7、开启 sentinel 代理 feign 功能；在 application.properties 中配置
        
        *   ```properties
            feign.sentinel.enabled=true
            
            ```
            

> [注解支持 · alibaba/Sentinel Wiki · GitHub](https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81)
>
> 1、使用@SentinelResource，并定义 fallback
>
> ```java
> com.atguigu.gulimall.seckill.service.impl.SeckillServiceImpl
> @SentinelResource(value = "getCurrentSeckillSkusResource",blockHandler = "blockHandler")
> @Override
> public List<SeckillSkuRedisTo> getCurrentSeckillSkus() {
> 
> }
> 
> ```

Nacos
-----

> [Nacos Spring Cloud](https://nacos.io/zh-cn/docs/use-nacos-with-springcloud.html)

### 项目整合

```
  

![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)

*   1
*   2
*   3
*   4
*   5
*   6
*   7
*   8
*   9
*   10
*   11
*   12
*   13
*   14
*   15
*   16
*   17
*   18
*   19
*   20
*   21
*   22
*   23
*   24
*   25
*   26
*   27
*   28
*   29
*   30
*   31
*   32
*   33
*   34
*   35
*   36
*   37
*   38
*   39
*   40
*   41
*   42
*   43
*   44
*   45
*   46
*   47
*   48
*   49


```

### Nacos作为注册中心：

*   将微服务注册到 nacos 中
    
*   1、首先，修改 pom.xml 文件，引入 Nacos Discovery Starter。
    
*   2、在应用的 /src/main/resources/application.properties 配置文 件中配置 Nacos Server 地址
    
    *   ```properties
        spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
        
        ```
    
*   3、使用@EnableDiscoveryClient 开启服务注册发现功能
    
*   4、启动应用，观察 nacos 服务列表是否已经注册上服务
    
    *   > 注意：每一个应用都应该有名字，这样才能注册上去。修改 application.properties 文件
        >
        > spring.application.name=service-provider
        >
        > server.port=8000
    
*   5、注册更多的服务上去，测试使用 feign 远程调用
    
    *   > Nacos 使用三步
        >
        > 1、导包 nacos-discovery
        >
        > 2、写配置，指定 nacos 地址，指定应用的名字
        >
        > 3、开启服务注册发现功能@EnableDiscoveryClient
        >
        > Feign 使用三步
        >
        > 1、导包 openfeign
        >
        > 2、开启@EnableFeignClients 功能
        >
        > 3、编写接口，进行远程调用
        

### Nacos作为配置中心

*   1、pom.xml 引入 Nacos Config Starter。
    
*   2、在应用的 /src/main/resources/bootstrap.properties 配 置文件中配置 Nacos Config 元数据
    
    *   ```properties
        spring.application.name=nacos-config-example
        spring.cloud.nacos.config.server-addr=127.0.0.1:8848
        #指定命名空间
        spring.cloud.nacos.config.namespace=af7b6638-68dd-43a0-8bef-19dbaf2ae5c3 
        #指定分组  默认DEFAULT_GROUP
        spring.cloud.nacos.config.group=dev
        #主要配置应用名和配置中心地址
        
        ```
    
*   3、在 nacos 中添加配置
    
    *   在 nacos 中创建一个 **应用名.properties** 配置文件并编写配置
        
    *   > **Nacos Config** **数据结构**
        >
        > Nacos Config 主要通过 dataId 和 group 来唯一确定一条配置。
        >
        > Nacos Client 从 Nacos Server 端获取数据时，调用的是此接口 ConfigService.getConfig(String dataId, String group, long timeoutMs)。
        >
        > **Spring Cloud** **应用获取数据**
        >
        > **dataID**:
        >
        > 在 Nacos Config Starter 中，dataId 的拼接格式如下
        >
        > *   ${prefix} - ${spring.profiles.active} . ${file-extension} prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置。
        > *   spring.profiles.active 即为当前环境对应的 profile
        >
        > 注意，当 activeprofile 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 p r e f i x . {prefix}. prefix.{file-extension}
        >
        > file-extension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。 目前只支持 properties 类型。
        >
        > **Group**：
        >
        > Group 默认为 DEFAULT_GROUP，可以通过 spring.cloud.nacos.config.group 配置。
    
*   4、在应用中使用@Value 和@RefreshScope
    
    *   > 完成上述两步后，应用会从 Nacos Config 中获取相应的配置，并添加在 Spring Environment
        >
        > 的 PropertySources 中 。 这 里 我 们 使 用 @Value 注 解 来 将 对 应 的 配 置 注 入 到
        >
        > SampleController 的 userName 和 age 字段，并添加 @RefreshScope 打开动态刷新功能
        >
        > **@RefreshScope**
        >
        > class SampleController {
        >
        > **@Value(“${user.name}”)**
        >
        > String userName;
        >
        > **@Value(“${user.age}”)**
        >
        > int age;
        >
        > }
        

### Nacos进阶

*   **核心概念**
    
    *   **命名空间：配置隔离**
        
        *   用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 **Group** 或 **Data ID** 的
            
            配置。**Namespace** 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生
            
            产环境的资源（如配置、服务）隔离等
        
    *   **配置集：所有配置的集合**
        
        *   一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配
            
            置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级
            
            别等配置项。
        
    *   **配置集ID：类似文件名。** 
        
        *   Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。**Data ID** 通常用于组
            
            织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有
            
            意义的名称标识。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名
            
            规则保证全局唯一性。此命名规则非强制。
        
    *   **配置分组：默认所有的配置集都属于：DEFAULT_GROUP；**
        
        *   Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或
            
            Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个
            
            配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置
            
            分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和
            
            MQ_topic 配置。
    
*   **原理**
    
    *   **自动注入：** 
        *   NacosConfigStarter 实现了 org.springframework.cloud.bootstrap.config.PropertySourceLocator 接口，并将优先级设置成了最高。 在 Spring Cloud 应用启动阶段，会主动从 Nacos Server 端获取对应的数据，并将获取到的 数据转换成 PropertySource 且注入到 Environment 的 PropertySources 属性中，所以使用 @Value 注解也能直接获取 Nacos Server 端配置的内容。
    *   **动态刷新：** 
        *   Nacos Config Starter 默认为所有获取数据成功的 Nacos 的配置项添加了监听功能，在监听 到服务端配置发生变化时会实时触发 org.springframework.cloud.context.refresh.ContextRefresher 的 refresh 方法 。
        *   如果需要对 Bean 进行动态刷新，请参照 Spring 和 Spring Cloud 规范。推荐给类添加**@RefreshScope** **或** **@ConfigurationProperties** 注解，
*   **3、加载多配置文件**
    
    *   ```properties
        spring.cloud.nacos.config.server-addr=127.0.0.1:8848
        spring.cloud.nacos.config.namespace=31098de9-fa28-41c9-b0bd-c754ce319ed4 
        spring.cloud.nacos.config.ext-config[0].data-id=gulimall-datasource.yml 
        #动态刷新
        spring.cloud.nacos.config.ext-config[0].refresh=false
        spring.cloud.nacos.config.ext-config[0].group=dev
        
        ```
    
*   **4、namespace 与 group 最佳实践**
    
    *   每个微服务创建自己的 namespace 进行隔离，group 来区分 dev，beta，prod 等环境

Gateway
-------

> [Spring Cloud Gateway](https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.3.RELEASE/single/spring-cloud-gateway.html)

*   **简介**
    *   网关作为流量的入口，常用功能包括路由转发、权限校验、限流控制等。
*   **特点**
    *   基于 Spring5，支持响应式编程和 SpringBoot2.0
    *   支持使用任何请求属性进行路由匹配
    *   特定于路由的断言和过滤器
    *   集成 Hystrix 进行断路保护
    *   集成服务发现功能
    *   易于编写 Predicates 和 Filters
    *   支持请求速率限制
    *   支持路径重写
*   **API网关优点**
    *   易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。
    *   易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在 每个微服务中进行认证。
    *   减少了客户端与各个微服务之间的交互次数。
*   **核心概率**
    *   **路由**
        *   路由是网关最基础的部分，路由信息有一个 ID、一个目的 URL、一组断言和一组 Filter 组成。如果断言路由为真，则说明请求的 URL 和配置匹配
    *   **断言**
        *   Java8 中的断言函数。Spring Cloud Gateway 中的断言函数输入类型是 Spring5.0 框 架中的 ServerWebExchange。Spring Cloud Gateway 中的断言函数允许开发者去定义匹配 来自于 http request 中的任何信息，比如请求头和参数等。
    *   **过滤器**
        *   一个标准的 Spring webFilter。Spring cloud gateway 中的 filter 分为两种类型的 Filter，分别是 Gateway Filter 和 Global Filter。过滤器 Filter 将会对请求和响应进行修改 处理
    *   **满足某些断言（predicates）就路由到指定的地址（uri），使用指定的过滤器（filter）**

> ```
> `spring:
> cloud:
>  gateway:
>    routes:
>         - id: test_route
>           uri: https://www.baidu.com
>           predicates:
>             - Query=url,baidu
> 
>        - id: product_route
>           uri: lb://gulimall-product
>           predicates:
>             - Path=/api/product/**
>           filters:
>             - RewritePath=/api/?(?<segment>.*),/$\{segment}
> 
>        - id: gulimall_host_route
>           uri: lb://gulimall-product
>           predicates:
>             - Host=gulimall.com,item.gulimall.com` 
> 
> ![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)
> 
> *   1
> *   2
> *   3
> *   4
> *   5
> *   6
> *   7
> *   8
> *   9
> *   10
> *   11
> *   12
> *   13
> *   14
> *   15
> *   16
> *   17
> *   18
> *   19
> *   20
> 
> 
> ```

Feign
-----

**Feign** **声明式远程调用**

*   简介
    
    *   Feign 是一个声明式的 HTTP 客户端，它的目的就是让远程调用更加简单。
    *   Feign 整合了 **Ribbon（负载均衡）和 Hystrix(服务熔断)，**
*   **使用**
    
    *   1、引入依赖 spring-cloud-starter-openfeign
        
    *   2、开启 feign 功能 @EnableFeignClients(basePackages = “com.atguigu.gulimall.member.feign”)
        
    *   3、声明远程接口
        
        *   ```java
            
            @FeignClient("gulimall-order")
            public interface OrderFeignService {
                
                @PostMapping("/order/order/listWithItem")
                R listWithItem(@RequestBody Map<String, Object> params);
            
            }
            
            ```
            

SpringCloud Alibaba 常用组件端口号总结
-----------------------------

*   Nacos 默认端口号：8848
    
    *   ```properties
        #*************** Spring Boot Related Configurations ***************#
        ### Default web context path:
        server.servlet.contextPath=/nacos
        ### Default web server port:
        server.port=8848
        
        
        ```
    
*   Seata默认端口号：8091
    
*   Sentinel控制台默认运行在8080端口上
    

> Elasticsearch 默认端口 9200 搜索引擎 不属于SpringCloud Alibaba



项目名称：谷粒学苑
=====

*   凉州区乡村在线教育平台、正商书院在线教育平台、在线教育大数据分析平台、高等学校云课程平台

项目简介：
-----

*   本系统采用微服务架构设计,是一款基于微信公众号B2C模式的在线学习平台，该平台包含三大模块∶直播、教学与微信消息服务﹔平台会定期推出直播课程，方便学员与名师之间的交流互动，学员也可以购买教学视频在线学习，分享直播与教学视频获取平台收益，平台支持直播、腾讯云视频点播等一系列功能，为用户构建了一个全方位的在线学习平台。

系统架构：
-----

*   该系用采用SpringCloud架构，利用SpringBoot构建应用，利用Nacos作为服务的注册、配置中心，利用OpenFeign实现与其他模块进行交互，利用Gateway作为服务网关，利用RabbitMQ作为消息队列，实现流量削峰，异步解耦，利用Redis作为缓存解决读多写少的场景，利用MySQL进行持久化，利用MyBatisPlus作为持久化框架，利用Nginx作为反向代理web服务器。

我的职责:
-----

*   完成平台**会员管理，讲师管理，课程管理，文章资讯，问答管理，短信管理**等服务模块的接口开发；
*   整合**EasyExcel**开源Excel处理框架，采用**一行一行**的解析模式，并将一行的解析结果以**观察者的模式**通知处理，**大大减少占用内存**,**提高Excel处理效率**；
*   整合**开通阿里云短信服务**，支持**快速发送手机验证码、短信通知**，为用户**提供通信服务**，**完善系统用户登陆与注册功能**；
*   整合**第三方文件上传服务**，如**阿里云对象存储**，基于服务端签名后直传，**保证文件传输的安全性**；
*   整合**阿里云视频点播服务**，用户服务端将**播放凭证**下发给客户端，使用视频点播**实现音视频上传、存储、处理和播放功能**；
*   基于 **Token** 的认证授权机制：**JWT**，通过对登录用户颁发登录凭证，**实现登录模块认证授权功能；**
*   使用**Redis**进行**热点信息缓存**，如把**首页接口 等读多写少的数据**缓存到redis缓存中，**减少数据库压力和提高访问速度**；
*   基于**MySQL数据库**进行**分库分表**，**解决由于数据量过大而导致数据库性能降低**的问题，**提高了系统的稳定性和负载能力;**
*   整合**Canal数据库同步工具**，采用**实时同步数据库表**的方式**实现实时统计每天注册与登录人数**，**提高数据处理效率，降低耦合度**；
*   使用**RabbitMQ消息队列**实现**流量削峰**，以及服务与服务之间的**异步解耦**，**提高服务器的响应速度**；
*   使用**Nacos作为注册中心与配置中心**，将服务名称及其对应地址进行存储，实现服务地址的**注册与发现**以及**配置动态加载**等功能
*   使用**Getaway 网关进行路由转发、权限验证以及负载均衡**，**自定义全局过滤器**并基于**JWT**的方式对用户身份进行识别，支持配置接口**未认证拦截功能**；
*   整合**OAuth2.0协议授权**，使用AccessToken调用开发API获取用户信息，**支持微信、QQ等第三方登陆；**
*   使用**RSA算法保证数据加密安全**，成功对接第三方支付功能，订单付款支持**支付宝、微信支付**等第三方支付服务。

核心业务
----

### 项目简介

*   谷粒学院，是一个B2C模式的职业技能在线教育系统，分为前台用户系统和后台运营平台。‘

![](A:\study\学习笔记\谷粒商城简历.assets\848c24e7cc7547f4bd4a654c104baf31.png#pic_center)

### 项目架构

**架构设计需要考虑的几个方面：** 

*   **性能：**主要考虑访问频率，每个用户每天的访问次数。项目初始阶段用户的访问量并不大，如果考虑做运营推广，可能会迎来服务器访问量骤增，因此要考虑**分布式部署，引入缓存**
*   **可扩展性：**系统功能会随着用户量的增加以及多变的互联网用户需求不断地扩展，因此考虑到系统的可扩展性的要求需要**使用微服务架构，引入消息中间件**
*   **高可用：**  系统一旦宕机，将会带来不可挽回的损失，因此必须做负载均衡，甚至是异地多活这类复杂的方案。如果数据丢失，修复将会非常麻烦，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计 MySQL 同机房主备方案；针对机房故障，我们需要设计 MySQL 跨机房同步方案。
*   **安全性：**  系统的信息有一定的隐私性，例如用户的个人身份信息，不包含强隐私（例如玉照、情感）的信息，因此使用账号密码管理、数据库访问权限控制即可。
*   **成本：**  视频类网站的主要成本在于服务器成本、流量成本、存储成本、流媒体研发成本，中小型公司可以考虑使用云服务器和云服务。

![](A:\study\学习笔记\谷粒商城简历.assets\1110629c2fa44d1c9085d476bfadda29.png#pic_center)

项目总结：
-----

### 1、项目描述

#### （1）第一部分

*   在线教育系统，分为前台网站系统和后台运营平台，B2C模式。
*   前台用户系统包括课程、讲师、问答、文章几大大部分，使用了微服务技术架构，前后端分离开发。
*   后端的主要技术架构是：SpringBoot + SpringCloud + MyBatis-Plus + HttpClient + MySQL + Maven+EasyExcel+ nginx
*   前端的架构是：Node.js + Vue.js +element-ui+NUXT+ECharts
*   其他涉及到的中间件包括Redis、阿里云OSS、阿里云视频点播
*   业务中使用了ECharts做图表展示，使用EasyExcel完成分类批量添加、注册分布式单点登录使用了JWT

#### （2）第二部分

*   项目前后端分离开发，后端采用SpringCloud微服务架构，持久层用的是MyBatis-Plus，微服务分库设计，使用Swagger生成接口文档
*   接入了阿里云视频点播、阿里云OSS。
*   系统分为前台用户系统和后台管理系统两部分。
*   前台用户系统包括：首页、课程、名师、问答、文章。
*   后台管理系统包括：讲师管理、课程分类管理、课程管理、统计分析、Banner管理、订单管理、权限管理等功能。
*   在线教育计费案例：
    *   小A是一名杭州的创业者，带领团队研发了一个在线教育平台。他希望把视频托管在阿里云上，存量视频大约1000个，占用存储空间近1T，每月预计新增视频100个，并新增存储约100G，课程视频的时长集中在20-40分钟，并且按照不同课程进行分类管理。为了保障各端的观看效果，计划为用户提供“标清480P”和“高清720P”两种清晰度。目前已有用户400人左右，每日平均视频观看次数1000次，在移动端和PC端观看次数比例大致为3:1。

![](A:\study\学习笔记\谷粒商城简历.assets\206a0eccfb8345f2bd0d88d0271c817a.png)

### 2、这是一个项目还是一个产品

*   这是一个产品
*   1.0版本是单体应用：SSM
*   2.0版本加入了SpringCloud，将一些关键业务和访问量比较大的部分分离了出去
*   目前独立出来的服务有教学服务、视频点播服务、用户服务、统计分析服务、网关服务

### 3、测试要求

*   首页和视频详情页qps单机qps要求 2000+
*   经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS
*   QPS = 并发量 / 平均响应时间

### 4、企业中的项目（产品）[开发流程](https://so.csdn.net/so/search?q=%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B&spm=1001.2101.3001.7020)

一个中大型项目的开发流程

1、需求调研（产品经理）

2、[需求评审](https://so.csdn.net/so/search?q=%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1&spm=1001.2101.3001.7020)（产品/设计/前端/后端/测试/运营）

3、立项（项目经理、品管）

4、[UI设计](https://so.csdn.net/so/search?q=UI%E8%AE%BE%E8%AE%A1&spm=1001.2101.3001.7020)

5、开发

*   架构、数据库设计、API文档、MOCK数据、开发、单元测试
*   前端
*   后端

6、前端后端联调

7、项目提测：黑盒白盒、压力测试（qps） loadrunner

8、bug修改

9、回归测试

10、运维和部署上线

11、灰度发布

12、全量发布

13、维护和运营

5、系统中都有那些角色？数据库是怎么设计的？

*   前台：会员（学员）
*   后台：系统管理员、运营人员
*   后台分库，每个微服务一个独立的数据库，使用了分布式id生成器

### 6、视频点播是怎么实现的（流媒体你们是怎么实现的）

*   我们直接接入了阿里云的云视频点播。云平台上的功能包括视频上传、转码、加密、智能审核、监控统计等。
*   还包括视频播放功能，阿里云还提供了一个视频播放器。

### 7、前后端联调经常遇到的问题：

1、请求方式post、get

2、json、x-wwww-form-urlencoded混乱的错误

3、后台必要的参数，前端省略了

4、数据类型不匹配

5、空指针异常

6、分布式系统中分布式id生成器生成的id 长度过大（19个字符长度的整数），js无法解析（js智能解析16个长度：2的53次幂）

 id策略改成 ID\_WORKER\_STR

### 8、前后端分离项目中的跨域问题是如何解决的

*   后端服务器配置：我们的项目中是通过Spring注解解决跨域的 @CrossOrigin
*   也可以使用nginx反向代理、httpClient、网关

### 9、说说你做了哪个部分、遇到了什么问题、怎么解决的

*   问题1：
    
    *   分布式id生成器在前端无法处理，总是在后三位进行四舍五入。
        
    *   分布式id生成器生成的id是19个字符的长度，前端javascript脚本对整数的处理能力只有2的53次方，也就是最多只能处理16个字符
        
    *   解决的方案是把id在程序中设置成了字符串的性质
    
*   问题2：
    
    *   项目迁移到Spring-Cloud的时候，经过网关时，前端传递的cookie后端一只获取不了，看了cloud中zuul的源码，发现向下游传递数据的时候，zull默认过滤了敏感信息，将cookie过滤掉了
    *   解决的方案是在配置文件中将请求头的过滤清除掉，使cookie可以向下游传递
*   问题3…
    

### 10、分布式系统的id生成策略

https://www.cnblogs.com/haoxinyue/p/5208136.html

### 11、项目组有多少人，人员如何组成？

*   4个成员
    *   2前端 2后端

### 12、分布式系统的CAP原理

**CAP定理：** 

*   指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。
*   一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时）
*   可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间）
*   分区容错性（P）：分区容错性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好）

**CA 满足的情况下，P不能满足的原因：** 

*   数据同步©需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足

**CP 满足的情况下，A不能满足的原因：** 

*   数据同步©需要时间, 机器数量也多§，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足

**AP 满足的情况下，C不能满足的原因：** 

*   机器数量也多§，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足

**注册中心选择的原则：** 

*   Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足
    
*   Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化
    

**结论：** 

*   分布式系统中P,肯定要满足，所以我们只能在一致性和可用性之间进行权衡
*   如果要求一致性，则选择zookeeper，如金融行业
*   如果要求可用性，则Eureka，如教育、电商系统
*   没有最好的选择，最好的选择是根据业务场景来进行架构设计

### 13、**前端渲染和后端渲染有什么区别**

*   前端渲染是返回json给前端，通过javascript将数据绑定到页面上
*   后端渲染是在服务器端将页面生成直接发送给服务器，有利于SEO的优化

**14、能画一下系统架构图吗**  
![](A:\study\学习笔记\谷粒商城简历.assets\0b6fe07f2c9e490bb2c9de6149124fb1.png#pic_center)

全网最全-Java简历优化-专业技能
==================

* * *

### 北邮大佬Java简历-专业技能部分

*   熟练掌握**Java核心知识、JUC、HashMap、斐波那契散列**等，具备良好的面向对象编程思想。
*   熟练掌握**Java设计模式，如工厂、代理、组合、策略**等设计模式，并善用设计原则构建可复用代码。
*   熟练使用 **IDEA、Eclipse**等编译工具以及 **Navicat、PostMan、Git、Maven、SVN**等开发工具。
*   深入理解**JVM底层原理**，熟悉JVM各类垃圾收集器的使用及核心参数的调优，**具备一定的JVM调优能力。** 
*   阅读并编写过**Spring 全链路核心功能源码**，如**AOP、IOC**，对源码有一定的理解，并能运用到实际业务开发中。
*   深入理解**Spring Boot,Spring Cloud**等微服务框架的设计原理及底层架构，熟悉**各种微服务架构设计**, 比如服务注册与发现，服务降级，限流，熔断，服务网关路由设计，服务安全认证架构。
*   熟悉 **Dubbo、Zookeeper**等分布式服务协调与治理等技术。
*   熟练掌握MySQL，掌握 MySQL **主从同步，读写分离技术以及集群的搭建**，**具备一定的SQL调优能力。** 
*   深入理解Redis线程模型，熟练掌握**Redis 的核心数据结构的使用场景**，熟悉各种缓存高并发的使用场景，比如缓存雪崩,缓存穿透等。
*   熟练掌握分布式场景中的常见的技术问题及解决，比如**分布式锁，分布式事务，分布式session，分布式任务调度。** 
*   熟悉 **RabbitMQ、Kafka**等常用的消息中间件进行**消息的异步数据处理**。
*   了解分布式搜索引擎ElasticSearch，并能**基于ELK+Kafka 搭建分布式日志收集系统**，以及×-pack-jdbc的扩展使用。
*   熟悉 docker 常用命令，能够实现**基于docker+Jenkins 实现自动化部署熟练运用Java Web技术**，包括 JSP、Servlet、EL 表达式、JSTL等技术。掌握Linux常用命令，了解 Nginx服务器的反向代理、负载均衡、动静分离等。
*   熟练运用**DDD四层架构领域驱动设计**,构建出易于迭代和维护的工程架构，遵守整洁代码、洋葱架构设计思想。

* * *

### 清华大佬Java简历-专业技能部分

*   **Java 基础:** 熟练掌握Java常用包以及Spring Boot ，Spring Cloud Alibaba框架的使用。熟悉常用库的调用，熟悉JUc , JVM，JMM内存模型。以及常用设计模式。有使用Caffeine实现多级缓存的开发经验。熟悉io多路复用和零拷贝技术。平时有刷算法的习惯
*   **源码∶**对HashMap,ConcurrentHashMap,ThreadLocal,ReentrantLock,线程池等等源码一行一行debug源码，并对每一行源码加了注释。大致看过spring,redis,netty , rocketmq源码。知道他的实现原理和过程。
*   **架构:** 了解常见的系统设计与架构设计
*   **信息通信技术∶**熟悉Kafka,RocketMq等消息队列的使用。能够使用Netty完成国标32960协议的编码解码。能够通过websocket协议完成和app的实时通信。通过zk搭建websocket服务的集群
*   **数据库相关∶**熟悉MySQL等关系型数据库使用和底层原理，以及Mycat实现MySQL的高可用架构。熟悉Redis非关系型数据的使用并看过底层源码，并熟悉使用redis在高并发作为分布式锁，分布式事务，分布式存储的使用场景
*   **部署相关∶**了解docker和k8s的基本使用
*   **计算机基础∶**熟悉计算机网络原理，操作系统原理，以及常用数据结构和算法。
*   **大数据:** 了解Hadoop , hbase,flink的使用，以及zk和dubbo
*   **团队协作∶**熟练使用Git进行团队协作开发。能够使用Apifox工具与前端，产品，测试共同完成api的开发与测试
*   **物联网∶**熟悉mqtt协议，以及emqx开源服务的使用，能够熟悉对接各种物联网设备和自定义协议
*   **其他∶**熟悉html,css,JavaScript，以及vue框架，并可以使用前端技术完成后台管理系统的编写。了解python和go的基本语法。还有postgre,mogodb,hbase,等大数据数据库的使用经验。

* * *

### 极兔大佬Java简历-专业技能部分

*   具有扎实的Java基础，熟悉面向对象、**多线程、集合**等基础开发技术，对**ArrayList 、 HashMap 、ConcurrentHashMap、锁机制、volatile 、 CAS、原子类**具有一定的理解
*   深入理解**JVM、JMM**，熟悉**垃圾收集机制、GC算法、类加载器**、对常见**JVM故障分析**、**JDK常用工具命令、JVM调优**有一定的了解;
*   熟悉MySQL，对**底层数据结构、索引、MVCC机制、BufferPool缓存机制**有一定的了解;
*   熟悉Spring，对**IOC、AOP 、Bean生命周期、三级缓存、依赖注入流程**有一定的了解;
*   熟悉Spring MVC，对**SpringMVC请求流程**有一定的了解;
*   熟悉SpringBoot，对**常用注解、自动装配原理、Jar启动流程、自定义Starter**有一定的了解;
*   熟悉掌握**Redis的核心数据结构的使用场景**，对**Redis的持久化、集群方案**有一定的了解，解决过一些线上的问题，比如**缓存穿透、缓存击穿、热点缓存重建**，对分布式锁实现有一定的理解;
*   了解Zookeeper，对**节点类型、分布式锁**实现有一定的理解;
*   熟悉RabbitMQ，了解常见问题解决方案，如消息**不丢失、幂等性、有序、堆积**;
*   了解SpringCloud相关组件的应用

* * *

### 中南大佬Java简历-专业技能部分

*   拥有扎实的Java编程基础，理解面向对象编程思想，熟悉常见设计模式(单例、策略、观察者、责任链等)
*   熟悉常用的数据结构与算法，阅读过队列、链表、AVL树、哈希表数据结构源码
*   熟悉JVM 虚拟机，GC 算法，垃圾收集器，类加载及对象分配过程，调优命令、参数及调优工具
*   熟悉JUC，阅读过JUC并发包部分源码，如ReentrantLock;熟悉ForkJoin框架及其分治思想;使用unsafe实现过部分原子操作类和并发工具类;熟悉使用CompletableFuture结合StreamAPI进行流式并发编程
*   熟悉关系数据库MySQL，如InnoDB存储引擎、索引、MVCC、事务、锁
*   熟悉NoSql数据库MongoDB，如集合、文档、副本集，了解副本集集群、分片集群高可用实现
*   熟悉SSM，对Spring 的 IOC容器、三级缓存机制、DI注入、AOP原理有一定了解
*   熟悉Zookeeper，使用Zookeeper实现过分布式队列，分布式锁，阅读过Curator分布式锁源码
*   熟悉Redis缓存数据库，如:持久化机制，主从复制原理，哨兵机制，分片集群等高可用分布式实现
*   了解Spring Cloud、Dubbo，如Nacos注册中心，Sentinel微服务治理，Dubbo RPC调用
*   了解RabbitMQ消息中间件，使用MQ实现过流量缓冲和延时队列
*   了解Nginx、OpenResty反向代理负载均衡服务器，具有基本的Lua脚本编程能力
*   了解H5、小程序开发，掌握Vue、elementUlI、小程序开发组件、uniapp前端开发技术
*   了解网络通信协议，了解HTTP/HTTPS、TCP/IP协议簇，对OSI七层网络模型有一定的了解

* * *

### Java基础、并发编程

*   具有扎实的Java基础，熟悉面向对象、多线程、集合等基础开发技术，对ArrayList . HashMap ConcurrentHashMap、锁机制、volatile , cas、原子类具有—定的理解，有研读过部分源码，并理解其底层实现。
*   Java基础扎实，熟练掌握多线程、数据结构、集合、反射等，具有良好的编码规范.
*   熟练掌握Java常用包以及**Spring Boot , Spring Cloud Alibaba**框架的使用。熟悉常用库的调用，熟悉**JUC , JVM，JMM内存模型**。以及常用设计模式。有使用Caffeine实现多级缓存的开发经验。熟悉**io多路复用和零拷贝技术。平时有刷算法的习惯。** 
*   对**HashMap,ConcurrentHashMap,ThreadLocal,ReentrantLock** ,线程池等等源码一行一行debug源码，并对每一行源码加了注释。大致看过spring,redis,netty, rocketmq源码。知道他的实现原理和过程。
*   了解常见的系统设计与架构设计
*   熟练掌握Java基础知识，熟练掌握集合原理(HashMap)、异常体系、反射机制
*   熟练掌握JUC并发编程的常用锁，了解AQS底层原理、JMM内存模型、线程池技术
*   熟练掌握Java核心知识、JUC、HashMap、斐波那契散列等，具备良好的面向对象编程思想。
*   熟练掌握Java设计模式，如工厂、代理、组合、策略等设计模式，并善用设计原则构建可复用代码。熟练使用 IDEA、Eclipse等编译工具以及 Navicat、PostMan、Git、Maven、SVN等开发工具。

### MySQL数据库

*   熟悉MySQL，对底层数据结构、索引、MVCC机制、BufferPool缓存机制有一定的了解;
*   熟悉MySQL，掌握数据库优化和SQL调优方案。熟练掌握Redis持久化和主从复制、哨兵模式、Cluster模式。
*   熟悉MySQL等关系型数据库使用和底层原理，以及Mycat实现MySQL的高可用架构。熟悉Redis非关系型数据的使用并看过底层源码，并熟悉使用redis在高并发作为分布式锁，分布式事务，分布式存储的使用场景
*   熟练掌握MySOL关系型数据库，熟悉InnoDB存储引擎、ACID事务特性，了解MVCC底层实现
*   熟练掌握MySQL，掌握 MySQL 主从同步，读写分离技术以及集群的搭建，具备一定的SQL调优能力。

### JVM虚拟机

*   深入理解JVM、JMM，熟悉垃圾收集机制、GC算法√类加载器、对常见JVM故障分析、JDK常用工具命令、JVM调优有一定的了解;
*   熟练掌握JVM基础原理，运行时内存结构，常见垃圾收集算法、熟悉类加载器及双亲委派机制
*   深入理解JVM底层原理，熟悉JVM各类垃圾收集器的使用及核心参数的调优，具备一定的JVM调优能力。

### Spring全家桶

*   深入理解Spring、SpringMVC、MyBatis、Spring Boot、SpringCloud等框架的设计原理以及底层架构。
*   熟悉Spring，对IOC、AOP 、Bean生命周期、三级缓存、依赖注入流程有一定的了解;
*   熟悉Spring MVC，对SpringMVC请求流程有一定的了解;
*   熟悉SpringBoot，对常用注解、自动装配原理、Jar启动流程、自定义Starter有一定的了解;
*   了解SpringCloud相关组件的应用
*   了解微服务框架SpringCloud Alibaba常用组件的应用;
*   熟练掌握Java常用包以及Spring Boot ，Spring Cloud Alibaba框架的使用。
*   熟练掌握Spring.Spring MVC、 MyBatis、SpringBoot等常用主流开发框架的使用
*   阅读并编写过Spring 全链路核心功能源码，如AOP、IOC，对源码有一定的理解，并能运用到实际业务开发中。
*   深入理解Spring Boot,Spring Cloud等微服务框架的设计原理及底层架构，熟悉各种微服务架构设计比如服务注册与发现，服务降级，限流，熔断，服务网关路由设计，服务安全认证架构。

### Redis、MQ、Zk、Es中间件部分

*   熟悉掌握Redis的核心数据结构的使用场景，对Redis的持久化、集群方案有一定的了解，解决过一些线上的问题，比如缓存穿透、/缓存击穿、热点缓存重建，对分布式锁实现有一定的理解;
*   熟练掌握Redis持久化和主从复制、哨兵模式、Cluster模式。熟悉MySQL，掌握数据库优化和SQL调优方案。
*   了解Zookeeper，对节点类型、分布式锁实现有一定的理解
*   熟悉RabbitMQ，了解常见问题解决方案，如消息不丢失、幂等性、有序、堆积﹔
*   了解Hadoop , hbase,flink的使用，以及zk和dubbo
*   熟悉Kafka,RocketMq等消息队列的使用。能够使用Netty完成国标32960协议的编码解码。能够通过websocket协议完成和app的实时通信。通过zk搭建websocket服务的集群
*   了解Redis缓存中间件，RDB和AOF持久化机制、Redis高可用方案，了解Kafka消息队列
*   熟悉 Dubbo、Zookeeper等分布式服务协调与治理等技术。
*   深入理解Redis线程模型，熟练掌握Redis 的核心数据结构的使用场景，熟悉各种缓存高并发的使用场景，比如缓存雪崩,缓存穿透等。
*   熟练掌握分布式场景中的常见的技术问题及解决，比如分布式锁，分布式事务，分布式session，分布式任务调度。
*   熟悉 RabbitMQ、Kafka等常用的消息中间件进行消息的异步数据处理。
*   了解分布式搜索引擎ElasticSearch，并能基于ELK+Kafka 搭建分布式日志收集系统，以及×-pack-jdbc的扩展使用。

### 计算机网络、操作系统、设计模式、数据结构

*   熟悉计算机网络、操作系统等基础知识，掌握常见的设计模式。
*   熟悉计算机网络原理，操作系统原理，以及常用数据结构和算法。
*   熟练掌握数据结构与算法、操作系统、计算机网络等相关基础知识
*   熟悉常见的数据结构以及常用的算法

### Linux基础、前端

*   掌握Linux常用命令，熟悉前端三件套、Vue等前端技术的使用。熟悉掌握Git，有真实团队协作开发经验。
*   熟练使用Linux常用命令，熟练掌握Git版本控制工具、Maven依赖管理。
*   了解docker和k8s的基本使用
*   了解前端框架Vue、CSS、HTML、JS等页面控制技术;
*   熟悉html,css,JavaScript，以及vue框架，并可以使用前端技术完成后台管理系统的编写。
*   熟悉 docker 常用命令，能够实现基于docker+Jenkins 实现自动化部署熟练运用Java Web技术，包括 JSP、Servlet、EL 表达式、JSTL等技术。掌握Linux常用命令，了解 Nginx服务器的反向代理、负载均衡、动静分离等。

### 其他加分项

*   了解python和go的基本语法。还有postgre,mogodb,hbase,等大数据数据库的使用经验。
    
*   熟练使用Git进行团队协作开发。能够使用Apifox工具与前端，产品，测试共同完成api的开发与测试
    
*   熟悉mqtt协议，以及emqx开源服务的使用，能够熟悉对接各种物联网设备和自定义协议
    
*   熟悉html,css,JavaScript，以及vue框架，并可以使用前端技术完成后台管理系统的编写。
    
*   对于接口文档,Resultful规则等前后端分离开发有一定经验
    
*   熟练运用DDD四层架构领域驱动设计,构建出易于迭代和维护的工程架构，遵守整洁代码、洋葱架构设计思想。

全网最全-Java简历优化-优质项目经历
====================

* * *

应届生Java简历-项目经历部分
----------------

### 头条移动端web应用 （黑马头条）

*   **项目描述**
    *   该项目要求仿照目前比较流行的“今日头条” app，内容则以技术类文章为主，为终端学习用户提供精准的.感兴趣的技术文章，为技术类的自媒体人提供首运营的平台。该项自运用Spring Boot快速并发框架构建顽自工程，并结合Spring Cloud全家桶技术，实现后端个人中心、自媒体、管理中心等微服务。该项目是一个多平台联合使用工程，本人负责真中文章为主线的核心业务。
*   **技术选型:** Spring+SpringBoot+SpringCloud+MySQL+MybatisPlus+Redis+Kafka
*   **我的职责：** 
    *   运用MyCat数据库中间件计算，对系统数据进行分库分表，提升系统数据层性能
    *   运用Kafka完成内部系统消息通知，与客服端系统消息通知，以及实时数据计算
    *   运用Redis缓存技术，实现热数据的计算，NoSession等功能，提升系统性能指标
    *   运用DFA算法实现敏感词过滤，并结合阿里云图片文本审核实现三轮高效审核
    *   运用Es搜索技术，对冷数据，文章数据建立索引，保证冷数据，文章查询性能
    *   运用cannal组件以及消息队列来保证数据库和缓存的一致性。
    *   运用Redis的集合数据类型，来解决点赞，相互关注功能。
*   **个人收获：** 
    *   学习Spring boot2.0项目封装配置方式和Spring Cloud nacos注册中心的搭建、数据库分库分表设计技巧、Kafka消息队列的生产者消费者的基本原理和机制以及Redis、Es等相关中间件

### 仿大众点评项目 （黑马点评）

*   **项目描述：**  一个基本功能完整的项目。项目主要功能有∶基于手机号码注册方式，验证码使用redis进行一个有效时间内的缓存。支持用户查看附近商铺，以及发布动态，实现了点赞，关注以及通知。
*   **项目功能:**
    *   通过对登录用户颁发登录凭证，通过JWT方式，来完成登录模块功能。
    *   对于频繁要使用的数据，比如附近商铺信息和登录信息使用Redis进行缓存,提高服务器的性能。
    *   通过对于秒杀和一人一单功能，通过逐步改进分布式锁的方案，利用meter工具进行压测，使得在多线程情况下每次一个订单只能抢一个优惠券。
    *   使用Redis的集合数据类型，来解决点赞，相互关注功能。
    *   使用RabbitMQ，在用户进行点赞，评论，关注后放入消息队列对于系统进行解耦。
    *   使用cannal组件以及消息队列来保证数据库和缓存的一致性。
*   **项目收获：** 
    *   熟悉了SpringBoot框架下开发项日的流程
    *   对于分布式锁实现有了更深的了解，并对Redis使用场景以及优点有了更多认识,
    *   了解到使用消息队列的好处，异步处理和同步相对比的优缺点。
    *   对于分布式缓存，多级缓存机制以及实现有了初步的认识.

### RPC框架

*   **项目描述**
    *   基于Java实现的轻量级RPC框架，该框架可以解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题，通信协议解决客户端和服务端采用哪种数据传输协议的简题，序列化和反序列化解决传输过程的编码问题
*   **技术选型：**  Netty+ Kyro+Nacos
*   **我的职责：** 
    *   实现了基于Netty的网络传输方式，提高了系统稳定性和开发速度
    *   使用开源的序列化机制Kyro替代JDK自带的序列化机制，解决了JDK序列化方法效率低，不安全的问题基于随机算法、轮转算法、一致性Hash算法的负载均衡策略
    *   通过使用Nacos作为注册中心，将服务名称及其对应地址进行存储，实现服务地址的注册与发现
*   **个人收获：** 
    *   学习RPC框架的底层原理和各种Java编码实践，提高了自己对于所掌握的知识的运用水平

* * *

北邮大佬Java简历-项目经历部分
-----------------

### 营销活动平台一Lottery [微服务](https://so.csdn.net/so/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&spm=1001.2101.3001.7020)抽奖系统

*   **项目名称:** 营销活动平台一Lottery 微服务抽奖系统
*   **系统架构:** 以 DDD领域驱动设计开发，微服务拆分的分布式系统架构
*   **核心技术:** SpringBoot、Mybatis、Dubbo、MQ、MySQL、XDB-Router、ES、ZK
*   **项目描述:** Lottery抽奖系统，是营销活动平台中的一个重要微服务，用于满足C端人群拉新、促活、留存的系统。系统根据微服务的界限上下文，运用抽象、分治和DDD知识，拆解服务边界、凝练领域服务功能。以围绕抽奖服务,解耦功能流程，建设领域服务，包括:规则引擎、抽奖策略、活动玩法、奖品发放等。来满足业务产品快速迭代上线的诉求，减低研发持续投入成本，提升交付效率。
*   **我的职责：** 
    *   构建以DDD 分层结构的处理方式,搭建整个抽奖系统架构。
    *   运用设计原则和工厂、代理、模板、组合、策略等设计模式的综合使用，搭建和开发方便维护和易于迭代的系统工程。
    *   鉴于系统内有较多的规则策略过滤，包括:准入、人群、风控、A/BTest等诉求，以适合系统规模可快速开发和使用的方式，搭建去中心化的量化人群规则引擎组件，通过业务诉求对Logic 的扩展和内置引擎执行器的使用，完成自由组合的人群过滤服务。降低共性功能重复开发所带来的成本问题，提供研发效率。
    *   应实际秒杀峰值场景TPS 5000~8000的诉求，开发统一路由组件，不仅可以满足差异化不同字段的分库和分表组合，以及 Redis库存分片和秒杀滑动库存分块，开发统一路由XDB-Router 的 SpringBoot Starter技术组件。此套组件经历数次大促活动场景，支持横向扩展，可以满足业务规模的快速增长。

### 自动化API提取和交付质量分析服务

*   **项目名称:** 自动化API提取和交付质量分析服务
*   **系统架构:** 基于IDEA Plugin插件开发与ASM字节码增强技术，采集工程运行信息核心技术:IDEA Plugin SDK、ASM、Swing.MySQL、SpringBoot、TTL
*   **项目描述∶** 这是一款用于帮助研发与测试，建立起标准可调试的动态自动化API服务,提升交付质量的系统。插件以 IntelliJ IDEA为底座，通过SDK的方式结合字节码增强技术。采集 IntelliJ IDEA单元测试运行时的接口信息，包括:工程名称、开发分支、开发人员、接口名称、出参、入参、异常、耗时等，并把这些通过 Socket回传到数据中心，处理为整个工程接口的全地图,让整个工程从开发、调试、提测到交付都成透明化，提高整体的交付质量。
*   **我的职责:**
    *   以架构师的职责调研如何降低每次开发到提测阶段，所需要人工编写接口文档的成本。以及通过什么方式无侵入式的处理接口文档的生产和维护。
    *   通过对ASM、Javassist、Byte-Buddy 等字节码框架的调研和测试,找到符合当前场景所需要的字节码增强框架，其中 Byte-Buddy上手难度更小,更易于后续其他研发共同开发。
    *   运用IDEA Plugin SDK插件的开发技术，拦截运行动作，插入字节码增强组件包。将采集信息回传到API数据中心进行分析、处理和提供最终的API文档。

### ES-ORM 框架开发

*   **项目名称:** ES-ORM 框架开发
*   **系统架构:** 技术迁移ORM开发到ES使用上，建设 SpringBoot Starter核心技术:SpringBoot、ES、Mybatis、dom4j、x-pack-jdbc
*   **项目描述:** 开发 ES-ORM框架，降低研发使用ES 数据查询硬编码方式的维护和迭代成本。通过ORM框架对XML和注解配置的方式，解析和映射语句处理器，代理IESDAO接口为具体的处理对象，并把对象通过扫描符合的路径和注解运用 BeanDefinitionRegistryPostProcessor把代理对象注册到Spring Bean容器中进行统一管理和使用，最终完成ORM框架的数据查询和封装操作。
*   **我的职责：** 
    *   负责组内的脚手架和提效工具的建设，对系统中通用共性的功能进行摘取凝练成统一的组件进行使用。这其中不只包括ES-ORM框架，还包括缓存组件、秒杀组件、服务治理、全链路监控等。
    *   对ES-ORM框架功能模块进行拆解和实现，分为;解析入口、数据源、代理层、绑定层、执行模块、异常处理、缓存服务等。
    *   分阶段功能验证和使用，逐步本地化，将内部的服务通过SPI的机制进行包装整合，允许组内其他场景诉求的扩展。

* * *

清华大佬Java简历-项目经历部分
-----------------

### 国家重点∶科技冬奥专项氢能出行大数据平台

*   **技术栈:** 基于springboot. nacos. redis.mysql , netty和rocketMq
*   **项目背景:** 用于实时监控冬奥会期间相关设备的实时状态
*   **我的贡献:**
    *   通过添加redis和本地缓存（从单一的mysql数据库，改成mysql-redis-caffeine多级存储）的方式，将数据接入模块的qps提高了原来的10倍。
    *   通过修改jvm的配置，并且使用对象池的方式减少了对象的创建过程和回收次数，从而减少数据接入时发生Gc的频率。使用添加线程池和异步的方式，提高系统的并发量
    *   使用cas的思想解决了数据写入并发问题
    *   完成各种功能模块的开发︰如∶为了解决nacos没有通知的功能。采用模拟nacos的无侵入思想，完成一个基于客户端和服务端并存的，采用心跳机制的服务监控系统。如果服务太久没有发送心跳包，则发送短信到开发人员手机中。
    *   通过学习redis源码思想，在项目再自己维护了一个全局时间戳，并发环境相比于直接调用System.currenttimemillis()有较大的性能优化。
    *   完成国标32960的netty解码器,并解决了半包问题
*   **实习收获：**  第一个有机会接触到较大并发的平台，通过跟导师的学习中，明白了各种并发问题的解决方式。也学会了使用各种市面上常用的开发框架。同时我也明白了在项目组要如何去团队合作，任何的修改要和上级沟通，在工作中要养成定时汇报任务进度的习惯.

* * *

极兔大佬Java简历-项目经历部分
-----------------

### 亿品项目

*   **项目简介：** 
    
    *   亿品项目属于TOB，主要涉及OA定制化办公系统、WMS仓储管理系统、多平台销售管理系统、PMS供应商管理系统等，业务遍及全球，对接国际各大电商平台如Amazon、Shopee,  
        Aliexpress、Lazada、Wish、Joom等，完成国内商品跨境销售的需求与管理。
    *   在Lazada平台有将近4万个店铺，Shopee平台有将近3万个店铺，Amazon平台也有将近2万个店铺，其他平台都大致将近1万个店铺，主要业务线是通过国内各大批发平台如1688采购物美价廉的商品进行包装通过各大跨境电商平台销售海外赚取差价，在国内外都有自己的仓储物流进行集中式管理，业务量主要取决于采购商品的种类以及刊登商品SKU以及模板的数量，已刊登的商品SKU将近1百万，模板数量将近20万，随着系统架构的升级，刊登的数量也越来越多，而我们主要的职责使公司的办公流程更加智能化、自动化，提高产品的开发速度，缩减采购的工作量，提高仓储运转效率。通过自动刊登功能减少销售人员的刊登工作，加大商品的铺货率，并且我们将所有平台所有店铺的客服交流工作集中到一个模块，提供了自动回复模板，极大减轻并简化了售后工作，比如提供自定义报表模块，可供销售人员自行定义并下载统计数据，为销售工作提供指导，同时也减少了后端开发人员的报表开发工作。
*   **系统架构：** 
    
    *   该系用采用SpringCloud架构，利用SpringBoot构建应用，利用Nacos实现服务的注册和发现，利用OpenFeign实现与其他系统进行交互，利用Hystrix’实现熔断和错误处理，利用Ribbon实现客户端负载均衡，利用Gateway管理外部系统访问，利用XXL-JOB完成任务调度，利用RabbitMQ实现操作异步、业务解耦、流量削峰，利用Redis作为缓存解决读多写少的场景以及作为**分布式锁**实现多系统间的同步操作，利用MySQL进行持久化，利用Mybatis作为持久化框架，利用**ShardingJDBC**解决Shopee在线商品表性能瓶颈
*   **个人贡献：** 
    
    *   实现内部系统与各跨境电商平台类目的映射以及属性处理，利用**模板设计模式**实现一套逻辑完成各平台关联业务
    *   在Shopee相关业处理过程中，使用**多线程进行Shopee订单的同步**，采用RabbitMQ解决促销期间订单**流量峰值**的问题;完成Shopee全球商品的标零补货，采用多线程解决批量全球商品数据处理过慢的问题，采用RabbitMQ进行**标零和补货的异步处理**，为了**可靠性传输**采用了全**局唯一ID**和**手动应答机制**
    *   处理Lazada优惠券相关业务的对接以及数据同步问题，采用多线程解决同步速度慢的问题
    *   根据可选条件以及配置进行导出数据，发送至用户邮箱，实现手动导出和定时任务导出
    *   解决工作中的难点，比如:使用反射和缓存的知识处理了Lazada相关业务接口代码的冗余，统一了平台接口调用;使用CompleteFuture**异步编排解决导出数据慢**的问题

* * *

中南大佬Java简历-项目经历部分
-----------------

### 电竞社交语音产品

*   **项目技术栈：**  SpringCloud、Redis、Dubbo、MongoDB、ES、OpenRestry、RabbitMQ、Kafka
*   **工作描述：**  负责公司游戏方向（世界大学生电子竞技联赛 WUCG）电竞社交语音产品的日常运营和维护；协助公司新的语音产品的构建和编码；学习并使用公司内部框架，参与设计部分框架
*   **我的职责：** 
    *   与 PM 对接并处理日常项目需求，累计修复线上 bug 100+，参与解决如缓存不一致、MQ 重复消费、ThreadLocal 消息泄露、Dubbo 异常调用等 bug，具有独立分析簇点链路并解决问题的能力
    *   为提升系统的并发量，使用大量合理的并发编程，保证接口 QPS 达标
    *   参与公司部分自研框架的开发和使用，如 OpenRestry-Caffine-Redis 分布式三级缓存框架，可以通过SpringBoot 自动装箱机制+注解完成缓存操作，开箱即用，天生保证缓存一致性，并且对业务代码零侵入
    *   在部分非核心接口上使用 Xxx-Job 替换公司自研的分布式调度框架，通过 Xxx-Job 特性，如：调度中心,执行器 HA、故障转移、分片任务、分片广播，保证分布式定时任务的高可用性
    *   协助处理多用户（5000+用户直播活动）环境下的系统并发问题，并通过 Sentinel 对微服务进行保护
*   **自我总结：** 
    *   通过这段时间的实习，通过接触公司技术栈，学习了许多企业级技术，例如两地三中心容灾备份、全球多写、企业级 SLB 等企业级解决方案；通过将学习到的知识在生产环境中运用，完善并提升了自己的技术栈水平；通过与项目PM、前端、测试、运维、产品等同学进行沟通学习，深入了解了一款产品的开发生命周期；通过与企业导师每周一次的谈话和总结，不断拓宽了自己的眼界和技术体系。

### e 小芯青年志愿者平台

* **项目描述：**  本项目是一个志愿者服务系统。由微信小程序、web 网页、服务器后端和硬件设备四部分组成，项目已在学校投入生产环境，其中子项目爱心雨伞获得学院五千元奖励并投放到各二级学院使用。

* **技术栈：**  SpringCloud、Zookeeper、Redis、RabbitMQ、OpenResty、Xxx-job、Docker、ES

*   **责任描述：** 
    *   **解决流量高峰时期，系统卡顿的问题。**  为提升系统并发量和降低系统响应时间，设计小程序、OpenResty、redis、Caffeine 组成的四级缓存链，通过 lua 脚本调用缓存链加快系统响应速度，系统平均响应时间降低 70%
    *   **解决缓存链数据不一致性问题**。使用 Alibaba Canal 监听 MySQL binlog 日志 + MQ 异步删除模式，实现解耦的同时做到业务代码零侵入，性能优于 MQ 缓存删除方式，可靠性优于缓存延迟双删策略
    *   **设计接口幂等性，解决爱心雨伞模块订单超买超卖问题。**  在大量用户产生订单的背景下，使用 Zookeeper 实现包含多个等待队列的分布式锁，对高并发场景下的共享资源进行保护
    *   **进一步提升系统并发量。项目中合理使用大量并发操作**，如使用 CompletableFuture 结合 StreamAPI 进行流式并发编程；使用 fork/Join 框架基于 Levenshtein Distance 编辑距离算法实现实时关键字提示
    *   **解决短信模块耗时较长的问题**。在用户获取验证码延时较长的背景下，利用 RabbitMQ 的队列机制对用户端与短信模块进行解耦、削峰，通过增加短信模块缓解了高并发情况下系统资源短缺的问题
    *   **通过添加 Xxx-job 分布式定时任务，解决志愿者模块核心链路和活动模型之间的脏写和数据同步的问题**
    *   **使用一周的时间学习了小程序的开发，** 独立开发微信小程序作为项目的用户端，部署运营并上线
    *   **解决网络延迟问题。**  为适应学校校园网特点和业务需要，将爱心雨伞模块与锁机通信协议由 TCP 更改为基于UDP 的 KCP 协议，在保证信息准确性的同时平均降低延迟 30%-40%
    *   **使用 Elasticsearch 实现全站内容搜索，相比 MySQL 搜索效率提升 80% 以上**

* * *

  * # 



# 面试

## 1、请介绍一下你自己

这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。

**举例：** 

*   我叫XX,今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通XXX开发技术体系，熟悉XXX设计模式。平常有时间看看博客，并且自己也喜欢在CSDN、简书、博客园等上写技术类的文章，与博友一起讨论。谢谢！

2.请分享一个你在信息矛盾或信息不全的情况下，必须迅速做出重要决定的例子。请说明 当时的情况，你采取了什么行动，最后结果如何?
---------------------------------------------------------------

**分析：**  这个问题考察的是面试者的决策能力和应对压力的能力。

**举例：**  在我之前的工作中，我们的团队需要在一个紧急时间内开发一个新的功能模块，以满足客户的需求。但是，在开始开发之前，我们没有完整的[需求文档](https://so.csdn.net/so/search?q=%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3&spm=1001.2101.3001.7020)，只有几个模糊的需求点和一些大致的想法。在这种信息不全的情况下，我采取了以下行动：

1.  与客户进行深入的交流，了解他们的期望和需求。
2.  与团队成员进行讨论，确定我们需要达成的目标和最重要的需求点。
3.  采用敏捷开发的方法，每周进行迭代，及时调整开发方向和需求点。

最终，我们成功地开发出了符合客户需求的功能模块，并在短时间内推出了产品。这个例子告诉我，在信息不全的情况下，重要的是要与客户和团队进行充分的沟通，并采用[敏捷开发](https://so.csdn.net/so/search?q=%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91&spm=1001.2101.3001.7020)的方法，及时调整开发方向和需求点，以确保项目的顺利完成。

3.请跟我们分享一次经历，尽管你有捷径可走，但你还是选择了最为诚信道德的方式去处理问题。请描述一下当时的情况，你是如何做的，结果是什么？
--------------------------------------------------------------------

**分析：**  这个问题考察的是面试者的决策能力和职业道德。

**举例：**  我曾经在一家公司工作，我们的客户要求我们在一个非常紧急的时间内完成一个项目。在项目进行中，我发现我们的一个同事在代码中使用了一些不合适的技巧和方法，这可能会导致一些潜在的安全问题。

虽然我知道如果我不说出来，这个项目可能会更快地完成，但我还是选择了立即通知我的上级领导，并提出了我的顾虑。我们的团队花费了额外的时间来修复这些问题，但最终我们成功地交付了一个安全可靠的产品，客户也非常满意。

我认为在我的职业生涯中，尊重道德和诚信是非常重要的。即使这可能会导致一些额外的工作或困难，但我相信只有这样才能建立一个真正可信赖的团队和公司。

2、为什么来北京/深圳/上海找工作？
------------------

面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。

**举例：** 

*   我来自河南，河南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，北京在国内T行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。

**注意：** 

*   不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来北京。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。

3、你为什么离开原来的公司（也就是我们常说的离职原因）？
----------------------------

**提示：** 

1.  最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在。
2.  避免把“离职原因”说得太详细、太具体。
3.  不能糁杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等。
4.  但也不能躲闪、回避，如“想换换环境”、“个人原因”等。
5.  不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。
6.  尽量使解释的理由为应聘者个人形象添彩。

**相关例子：** 

*   如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。

**分析：** 

*   除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。

4、你最大的缺点是什么？
------------

被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。

**举例：** 

*   这个问题好难回答啊！我想想·（亲和力表现，也缓解了自己的紧张情绪）我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。

5、你未来3-5年的[职业规划](https://so.csdn.net/so/search?q=%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92&spm=1001.2101.3001.7020)是怎样的（或者简单说下你未来对自己的规划）？
------------------------------------------------------------------------------------------------------------------------------------

大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。

**举例：** 

*   我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望35年内可以从开发做到架构师。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。

6、你对薪资的要求？
----------

如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。  
**举例：** 

*   我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。
    
    > 如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说10K12K之间，那样你将只会得到最低限底的数字，也就是10K。最好给出一个具体的数字。
    

7、什么时间能入职？
----------

大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还没有辞去上一份工作的话，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。

8、介绍一个你认为最熟悉的项目（项目经历）
---------------------

这个问题在技术面试时常被问到，问这个问题的意图可能是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。

你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影  
响。

你大可以和面试官谈谈在那个项目中自己获得的经验，这样会引起彼此的共鸣，有可能的话，说出一些自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。

9、如果我们公司录用你，你将怎样开展工作？
---------------------

很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。

**举例：** 

*   我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。

☆10、你还有什么问题问我吗？
---------------

这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就相当于自寻死路，没有问题，说明你对公司缺乏兴趣，而只是来寻找一笔客观的薪水的。

其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己将来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。

11、你对加班的看法？
-----------

实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。  
**举例：** 

*   如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。

12、你朋友对你的评价？
------------

**提示：**想从侧面了解一下你的性格及与人相处的问题。

**举例：** 

*   例一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。
*   例二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。

13、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？
----------------------------------------------

**提示：**  一段时间发现工作不适合我，有两种情况：

1.  如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；
2.  你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。

14、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？
---------------------------------------------

**提示：** 

1.  .原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。
2.  如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。
3.  还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。

15、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？
---------------------------------

**提示：** 

1.  我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。
2.  分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。
3.  总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。

16、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？
----------------------------------------

**提示：**  我首先不会找那位上级领导

1.  我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。
2.  他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。

17、谈谈你对跳槽的看法？
-------------

**提示：** 

1.  正常的“跳槽”能促进人才合理流动，应该支持。
2.  频繁的跳槽对单位和个人双方都不利，应该反对。

18、工作中你难以和同事、上司相处，你该怎么办？
------------------------

**提示：** 

1.  我会服从领导的指挥，配合同事的工作。
2.  我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。
3.  如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。
4.  作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。

19、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？
------------------------------------------------------------

**提示：** 

1.  成绩比较突出，得到领导的肯定是件好事情，以后更加努力。
2.  检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。·
3.  工作中，切勿伤害别人的自尊心。
4.  不再领导前拨弄是非。

20、你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？
--------------------------------------

**提示：**  公司组织参加的xxx的培训课程，平时工作不忙的时候再公司就可以学（可以多谈谈自己学的技术)。

21、你对于我们公司了解多少？
---------------

**提示：**  在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的0EM合作，自有品牌的部分则透过5海外经销商。

22、简单说下为什么会选择这份工作？
------------------

**提示：**  这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。

23、你最擅长的技术方向是什么？
----------------

**提示：**  尽量说一些和自己要应聘的职位相关的技术，来体现一下自己的热诚没有什么坏处。

24、你能为我们公司带来什么呢？
----------------

**提示：**  企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。

25、用简短的几个词概括下自己？
----------------

**提示：**  仅供参考哈：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，

26、你的业余爱好是什么？
-------------

**提示：**  找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。

27、作为被面试者给我打一下分？
----------------

**提示：**  试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的)。

28、喜饮这份工作的哪一点？
--------------

**提示：**  相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。

29、说说你对行业、技术发展趋势的看法？
--------------------

**提示：**  企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。

30、对工作的期望与目标何在？
---------------

**提示：**  这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。

31、针对于你应聘的岗位，你感觉你还欠缺什么？
-----------------------

**提示：**  企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。

32、你为什么愿意到我们公司来工作？
------------------

**提示：**  对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。

33、在平时的工作中，你和别人发生过争执吗？你是怎样解决的？
------------------------------

**提示：**  这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。

34、你做过的哪件事最令自己感到骄傲？
-------------------

**提示：**  这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。

35、你怎样看待自己的失敗？
--------------

**提示：**  我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。

36、什么会让你有成就感？
-------------

**提示：**  为贵公司竭力效劳，尽我所能，完成一个项目。

37、目前你认为你生活中最重要的是什么？
--------------------

**提示：**  对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。

38、工作中如果遇到与上级意见不一致时，你会怎么办？
--------------------------

**提示：** 

1.  一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”
2.  如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回

**答：**  “对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”  
**分析：**  这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。

39、你工作经验欠缺，如何能胜任这项工作？
---------------------

**一般回答的思路：** 

1.  如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。
2.  对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。
3.  如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”

**分析：**  这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。

40、你喜欢与什么样的上级共事？
----------------

**提示：** 

1.  通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。
2.  最好回避对上级具体的希望，多谈对自己的要求。
3.  如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。

**分析：**  这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。

41、简单说一下，你如何适应新的办公环境？
---------------------

**提示：** 

1.  办公室里每个人有各自的岗位与职责，不得擅离岗位。
2.  根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。
3.  多请示并及时汇报，遇到不明白的要虚心请教。
4.  抓间隙时间，多学习，努力提高自己的政治素质和业务水平。

42、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？
------------------------------

**提示：**  每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生话中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。

43、如果你在这次面试中没有被录用，你有什么打算？
-------------------------

**提示：**  现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。

我会从以下几个方面来正确看待这次失败：

1.  **要敢于面对**，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。
2.  **善于反思**，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。
3.  **走出阴影**，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。
4.  **认真工作**，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的成绩。
5.  **再接再厉**

44、假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？
----------------------------------------

**提示：**  我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。

*   如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。
*   如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。
*   如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。
    *   如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。
    *   如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竞工作做完了就完了，朋友还是可以再见面的。

45、谈谈你过去的工作经验中，最让你感觉受挫的事情？
--------------------------

**提示：**  曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。  
**分析：**  借此了解你对挫折的容忍度及调解方式。

46、如何安排自己的时间？会不会排斥加班？
---------------------

**提示：**  基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。  
**分析：**  虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。

47、你并非毕业于名牌院校？
--------------

**提示：**  是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。

48、怎样看待学历和能力？
-------------

**提示：**  学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？

49、你在以前的工作过程中都学习到了些什么？
----------------------

**提示：**  这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。

50、想过创业吗？
---------

**提示：**  这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？

51、除了本公司外，还应聘了哪些公司？
-------------------

**提示：**  很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。

项目名称：探花交友
=====

*   远亲不如近邻-“有好邻”社区社交服务APP、移动短视频社交平台
*   O2O同城社交APP、“曲园社交读书APP、高校留学生社交APP

项目简介：
-----

*   本项目是一个在线交友平台，在该平台中可以搜索附近的人，查看好友动态，平台还会通过大数据计算进行智能推荐，通过智能推荐可以找到更加匹配的好友，这样才能增进用户对产品的喜爱度。探花平台还提供了在线即时通讯功能，可以实时的与好友进行沟通，让沟通随时随地的进行。

系统架构：
-----

*   **前端:** flutter + android+环信SDK + redux + shared_preferences + connectivity + iconfont +webview + sqflite
*   **后端：**  Spring Boot + SpringMVC + Mybatis + MybatisPlus + MongoDB + Redis + RocketMQ + Spark + MLlib + Dubbo+ Elasticsearch geo

我的职责:
-----

*   完成平台**交友、圈子、消息 、小视频、个人中心**等服务模块的接口开发；
*   基于 **Token** 的认证授权机制：**JWT**，通过对登录用户颁发登录凭证，**实现登录模块认证授权功能；**
*   整合**第三方文件上传服务**，如阿里云对象存储，基于服务端签名后直传，**保证文件传输的安全性**；
*   使用**Elasticsearch geo 分布式搜索引擎**，解决了地理信息数据的存储、索引、查询和可视化等问题，**完成平台“附近的人”功能模块**；
*   采用**Spark + Mllib ，进行大规模数据的机器学习处理和分析**，帮助用户快速、准确地找到自己感兴趣的内容，**完成平台“智能推荐”功能模块**；
*   采用**MongoDB非关系型数据库，进行海量数据的存储**，解决了传统关系型数据库存储、扩展性和性能方面的问题，**具有高可用性和可扩展性**；
*   采用**FastDFS分布式文件系统，存储平台小视频数据**，实现了高可用性、可靠性和高性能的数据存储，同时**有效避免了单点故障和数据丢失问题；**
*   使用**虹软开放平台进行人脸识别**，解决了平台中的身份验证和安全问题，提高用户体验和平台安全性，**降低虚假账号和欺诈行为的风险**；
*   使用**阿里云进行短信验证码发送**，提高验证码发送的成功率和速度，节省开发和维护成本，**提高用户注册和登录的安全性和便捷性**；
*   采用**环信服务实现即时通讯**，解决了在线交友平台中用户无法及时沟通交流的问题，提高了用户的互动体验，**增加了用户粘性和平台活跃度**；
*   使用**Spring Cache方法级别缓存技术**，实现已经被调用过的指定的目标方法，直接从缓存中获取方法调用后的结果返回，**提高系统的响应速度；**
*   采用**Redis集群实现缓存的高可用**，解决平台在高并发情况下访问缓慢、压力大等问题，**提高了系统的响应速度和并发能力**；
*   整合**OAuth2.0协议授权**，使用AccessToken调用开发API获取用户信息，**支持微信、QQ、微博、Gitee、Github等第三方登陆；**
*   使用**RSA算法保证数据加密安全**，成功对接第三方支付功能，订单付款支持**支付宝、微信支付**等第三方支付服务。
*   使用**redis+lua脚本**防止重复提交攻击，**解决了用户利用浏览器刷新和回退重复提交数据的问题；**
*   利用**Jmeter工具**进行压测，找到在**多线程**情况下造成的**内存泄漏，并发与同步**等问题，**保证了系统在线上的处理能力和稳定性维持在一个标准范围内；**
*   采用**RocketMQ作为消息服务中间件**，可以解决平台中的高并发消息处理问题，提高消息传递的可靠性和效率，同时支持消息的持久化和顺序传递，**能够保证消息的正确性和一致性**。

技术架构
----

![](A:\study\学习笔记\谷粒商城简历.assets\e2c982eedee641ee86c987b384d70267.png#pic_center)

技术解决方案
------

*   使用Elasticsearch geo实现附近的人的解决方案
*   使用Spark + Mllib实现智能推荐的解决方案
*   使用MongoDB进行海量数据的存储的解决方案
*   使用采用分布式文件系统存储小视频数据的解决方案
*   使用虹软开放平台进行人脸识别的解决方案
*   使用阿里云进行短信验证码发送的解决方案

技术亮点
----

*   采用Elasticsearch geo实现地理位置查询
*   采用RocketMQ作为消息服务中间件
*   采用MongoDB进行海量数据的存储
*   采用Spark + Mllib实现智能推荐
*   采用环信服务实现即时通讯
*   采用分布式文件系统存储小视频数据
*   采用Apache Dobbo作为微服务架构技术
*   采用SpringBoot + Mybatis实现系统主架构
*   采用Redis集群实现缓存的高可用

开发方式
----

探花交友项目采用前后端分离的方式开发，就是前端由前端团队负责开发，后端负责接口的开发，这种开发方式有2点好处：

*   扬长避短，每个团队做自己擅长的事情
*   前后端并行开发，需要事先约定好接口地址以及各种参数、响应数据结构等

什么是接口？接口就是一个http的请求地址，在定义接口的时候主要就是去定义：请求路径，请求方式，请求参数，响应结果数据等内容。

基础环境
----

探花交友项目的开发统一使用提供的Centos7环境，该环境中部署安装了项目所需要的各种服务，如：MySQL、MongoDB、Redis、RocketMQ等。

*   虚拟机的root用户密码为：root123
*   默认参数：CPU：2核，内存：4G，硬盘：60G
*   IP地址建议设置为192.168.31.81，否则有些服务将不可用，比如：Redis、RocketMQ等。

核心业务：
-----

一、注册登录
------

业务说明：

用户通过手机验证码进行登录，如果是第一次登录则需要完善个人信息，在上传图片时，需要对上传的图片做人像的校验，防止用户上传非人像的图片作为头像。流程完成后，则登录成功。

流程：

![](A:\study\学习笔记\谷粒商城简历.assets\f9f0ae60dc7240a2a51a7d955cc0e68e.png#pic_center)

### 1.1、单点登录系统

为什么要使用单点登录系统？

以前实现的登录和注册是在同一个tomcat内部完成，我们现在的系统架构是每一个系统都是由一个团队进行维护，每个系统都是单独部署运行一个单独的tomcat，所以，不能将用户的登录信息保存到session中（多个tomcat的session是不能共享的），所以我们需要一个单独的系统来维护用户的登录信息。

![](A:\study\学习笔记\谷粒商城简历.assets\cf42dd467496491cbbf3ab9628f1c72a.png#pic_center)

### 1.2、短信验证码

发送短信验证码的流程：

![](A:\study\学习笔记\谷粒商城简历.assets\9c8a5c1a5a63456da9514caca7ff6022.png#pic_center)

流程说明：

*   用户向SSO系统发送请求，在请求中传递手机号；
*   SSO系统接收到请求后，生成随机验证码以及短信内容，请求阿里云短信服务；
*   阿里云短信服务接收到请求后，会进行一系列的验证，比如账号余额、短信模板是否正确等，最后向运营商发起请求；
*   运营商接收到请求后，向该手机号下发短信，用户即可收到短信；

### 1.3、JWT

JSON Web token简称JWT，是用于对应用程序上的用户进行身份验证的标记。也就是说, 使用 JWTS 的应用程序不再需要保存有关其用户的 cookie 或其他session数据。此特性便于可伸缩性, 同时保证应用程序的安全。

在身份验证过程中, 当用户使用其凭据成功登录时, 将返回 JSON Web token, 并且必须在本地保存 (通常在本地存储中)。

每当用户要访问受保护的路由或资源 (端点) 时, 用户代理(user agent)必须连同请求一起发送 JWT, 通常在授权标头中使用Bearer schema。后端服务器接收到带有 JWT 的请求时, 首先要做的是验证token。

**1.3.1、格式**

*   JWT就是一个字符串，经过加密处理与校验处理的字符串，形式为：A.B.C
    
*   A由JWT头部信息header经过base64加密得到
    
    *   ```mysql
        #默认的头信息
        {
         "alg":"HS256",
         "typ":"JWT"
        }
        #官网测试：https://jwt.io/
        #base64加密后的字符串为：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
        
        ```
    
*   B是payload，存放有效信息的地方，这些信息包含三个部分：
    
    *   标准中注册的声明 (建议但不强制使用)
        
        *   iss: jwt签发者
        *   sub: jwt所面向的用户
        *   aud: 接收jwt的一方
        *   exp: jwt的过期时间，这个过期时间必须要大于签发时间
        *   nbf: 定义在什么时间之前，该jwt都是不可用的.
        *   iat: jwt的签发时间
        *   jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
    *   公共的声明
        
        *   公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.
            
            但不建议添加敏感信息，因为该部分在客户端可解密.
        
    *   私有的声明
        
        *   私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64 是对称解密的，意味着该部分信息可以归类为明文信息。
            
            *   ```mysql
                #存放的数据：
                {
                 "sub":"1234567890", 
                 "name":"JohnDoe",
                 "iat":1516239022
                }
                #base64后的字符串为：
                eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIy fQ
                
                ```
    
*   C由A和B通过加密算法得到，用作对token进行校验，看是否有效
    
    *   这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。
        
        *   ```mysql
            #secret为：itcast
            #得到的加密字符串为：DwMTjJktoFFdClHqjJMRgYzICo6FJOUc3Jmev9EScBc
            
            #整体的token为：
            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI 6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.DwMTjJktoFFdClHqjJMRgYzICo6FJOUc 3Jmev9EScBc
            
            ```
            

**1.3.2流程**

![](A:\study\学习笔记\谷粒商城简历.assets\172467acf192438e8a296cb68200799d.png#pic_center)

二、完善个⼈信息
--------

⽤户在⾸次登录时需要完善个⼈信息，包括性别、昵称、⽣⽇、城市、头像等。其中，头像数据需要做图⽚上传，这⾥采⽤阿⾥云的OSS服务作为我们的图⽚服务器，并且对头像要做⼈脸识别，⾮⼈脸照⽚不得上传。

### 2.1、图⽚上传

#### 2.1.1、图⽚存储解决⽅案

实现图⽚上传服务，需要有存储的⽀持，那么我们的解决⽅案将以下⼏种：

*   直接将图⽚保存到服务的硬盘
    *   优点：开发便捷，成本低
    *   缺点：扩容困难
*   使⽤分布式⽂件系统进⾏存储
    *   优点：容易实现扩容
    *   缺点：开发复杂度稍⼤（有成熟的产品可以使⽤，⽐如：FastDFS）
*   使⽤nfs做存储
    *   优点：开发较为便捷
    *   缺点：需要有⼀定的运维知识进⾏部署和维护
*   使⽤第三⽅的存储服务
*   优点：开发简单，拥有强⼤功能，免维护
*   缺点：付费

在本套课程中选⽤阿⾥云的OSS服务进⾏图⽚存储。

#### 1.1.2、阿⾥云OSS存储

流程：

![](A:\study\学习笔记\谷粒商城简历.assets\fc738665aa504c9ba138d1b33c75f3d1.png#pic_center)

### 2.2、⼈脸识别

⼈脸识别技术采⽤虹软开放平台实现（免费使⽤）。官⽹：https://www.arcsoft.com.cn/

![](A:\study\学习笔记\谷粒商城简历.assets\c0b0e1ff289a46b883fda8f0c9f09a53.png#pic_center)

#### 1.2.1、使⽤说明

使⽤虹软平台需要先注册开发者账号：https://ai.arcsoft.com.cn/ucenter/user/userlogin

![](A:\study\学习笔记\谷粒商城简历.assets\46a85ae3f88e4bedb2f6cbf46033ff72.png#pic_center)

#### 2.3、系统架构

在开发完SSO系统中的登录功能后，接下来就需要实现其他的功能，在整体架构中，完成与APP对接的服务⼯程叫my-tanhua-server，真正的核⼼业务逻辑使⽤dubbo完成，其⼯程名叫：my-tanhua-dubbo，它们的架构示意图如下：

![](A:\study\学习笔记\谷粒商城简历.assets\2460b8aefec7425ea0ce4f91a545a007.png#pic_center)

说明：

*   客户端APP发起请求到Nginx，在Nginx中对请求做出判断，将请求转发⾄sso系统或server系统。
    
*   sso系统中，将对接第三⽅平台以及完成数据的缓存、消息发送、⽤户的注册登录功能。
    
*   server系统为APP提供了接⼝服务的⽀撑
    
    *   ⽤户请求中携带的token需要到sso系统中进⾏校验
        
    *   通过rpc调⽤dubbo中提供的服务，在dubbo服务中与MongoDB对接，完成数据的CRUD操作
        
    *   将⼀些数据缓存到Redis，从⽽提升数据查询性能
        
    *   ⽤户数据的查询将基于MySQL数据库进⾏查询
        

三、今⽇佳⼈
------

今⽇佳⼈，会推荐缘分值最⼤的⽤户，进⾏展现出来。缘分值的计算是由⽤户的⾏为进⾏打分，如：点击、点赞、评论、学历、婚姻状态等信息组合⽽成的。

实现：我们先不考虑推荐的逻辑，假设现在已经有推荐的结果，我们只需要从结果中查询到缘分值最⾼的⽤户就可以了。⾄于推荐的逻辑以及实现，我们将后⾯的课程中讲解。

流程：

![](A:\study\学习笔记\谷粒商城简历.assets\f3fecc002a004091b18452bc76f3cb1d.png#pic_center)

**实现描述：** 

*   需要根据前端定义的结构定义java对象
*   根据sso系统提供的接⼝查询当前登录⽤户的信息
*   根据dubbo系统提供的服务进⾏查询今⽇佳⼈数据

**解决MongoDB启动bug**

在项⽬中，添加了mongo的依赖的话，springboot就会⾃动去连接本地的mongo，由于他连接不上会导致出错。

解决：springboot中添加排除⾃动配置的注解 ：

```java
@SpringBootApplication(exclude= {MongoAutoConfiguration.class,MongoDataAutoConfiguration.class}) 

```

四、推荐列表
------

### 4.1缓存

在接⼝服务中，有必要对于接⼝进⾏缓存处理，尤其是GET请求，如果每个接⼝单独添加的话会存在很多的重复的逻辑，所以可以编写⼀套通⽤的解决⽅案。

实现思路：

*   通过拦截器实现对请求的拦截，在拦截器中实现缓存的命中。
*   通过ResponseBodyAdvice进⾏对响应的拦截，可以将数据缓存到Redis中。
*   考虑到，不能对于所有的请求都⼀⼑切，所以需要创建@Cache注解进⾏标记，只有标记的Controller才进⾏缓存处理。
*   缓存的处理中，仅针对GET请求处理，其他的请求均不做处理。

五、圈⼦功能
------

### 5.1、功能说明

探花交友项⽬中的圈⼦功能，类似微信的朋友圈，基本的功能为：发布动态、浏览好友动态、浏览推荐动态、点赞、评论、喜欢等功能。

### 5.2、实现⽅案分析

对于圈⼦功能的实现，我们需要对它的功能特点做分析：

*   数据量会随着⽤户数增⼤⽽增⼤
*   读多写少，⼀般⽽⾔，浏览朋友圈动态会多⼀些，发动态相对就会少⼀些
*   ⾮好友看不到其动态内容
*   ……

针对以上特点，我们来分析⼀下：

*   对于数据量⼤⽽⾔，显然不能够使⽤关系型数据库进⾏存储，我们需要通过MongoDB进⾏存储
*   对于读多写少的应⽤，尽可能的减少读取数据的成本
*   ⽐如说，⼀条SQL语句，单张表查询⼀定⽐多张表查询要快
*   条件越多的查询速度将越慢，尽可能的减少条件以提升查询速度

所以对于存储⽽⾔，主要是核⼼的4张表：

*   发布表：记录了所有⽤户的发布的东⻄信息，如图⽚、视频等。
*   相册：相册是每个⽤户独⽴的，记录了该⽤户所发布的所有内容。
*   评论：针对某个具体发布的朋友评论和点赞操作。
*   时间线：所谓“刷朋友圈”，就是刷时间线，就是⼀个⽤户所有的朋友的发布内容。

![](A:\study\学习笔记\谷粒商城简历.assets\b0ad72bc1ca14b848824a8bb653be52b.png#pic_center)

流程说明：

*   ⽤户发布动态，动态中⼀般包含了图⽚和⽂字，图⽚上传到阿⾥云，上传成功后拿到图⽚地址，将⽂字和图⽚地址进⾏持久化存储
*   ⾸先，需要将动态数据写⼊到发布表中，其次，再写⼊到⾃⼰的相册表中，需要注意的是，相册表中只包含了发布id，不会冗余存储发布数据
*   最后，需要将发布数据异步的写⼊到好友的时间线表中，之所以考虑异步操作，是因为希望发布能够尽快给⽤户反馈，发布成功
*   好友刷朋友圈时，实际上只需要查询⾃⼰的时间线表即可，这样最⼤限度的提升了查询速度，再配合redis的缓存，那速度将是⻜快的
*   ⽤户在对动态内容进⾏点赞、喜欢、评论操作时，只需要写⼊到评论表即可，该表中也是只会记录发布id，并不会冗余存储发布数据

### 5.3、统⼀校验token

在之前的开发中，我们会在每⼀个Service中对token做处理，相同的逻辑⼀定是要进⾏统⼀处理的，该如何处理呢？

由于程序是运⾏在web容器中，每⼀个HTTP请求都是⼀个独⽴线程，也就是可以理解成我们编写的应⽤程序运⾏在⼀个多线程的环境中，那么我们就可以使⽤ThreadLocal在HTTP请求的⽣命周期内进⾏存值、取值操作。

如下图：

![](A:\study\学习笔记\谷粒商城简历.assets\ebc9649b8de54eafbf2028ef3d7728c2.png#pic_center)

说明：

*   ⽤户的每⼀个请求，都是⼀个独⽴的线程
*   图中的TL就是ThreadLocal，⼀旦将数据绑定到ThreadLocal中，那么在整个请求的⽣命周期内都可以随时拿到ThreadLocal中当前线程的数据。

根据上⾯的分析，我们只需要在Controller请求之前进⾏对token做校验，如果token有效，则会拿到User对象，然后将该User对象保存到ThreadLocal中即可，最后放⾏请求，在后续的各个环节中都可以获取到该数据了。

如果token⽆效，给客户端响应401状态码，拦截请求，不再放⾏到Controller中。

由此可⻅，这个校验的逻辑是⽐较适合放在拦截器中完成的。

### 5.4、好友时间线数据

好友的时间线数据需要异步执⾏。这⾥使⽤Spring的@Async注解实现异步执⾏，其底层是通过启动独⽴线程来执⾏，从⽽可以异步执⾏。通过返回的CompletableFuture来判断是否执⾏成功以及是否存在异常。同时需要在启动类中添加@EnableAsync 开启异步的⽀持。

![](A:\study\学习笔记\谷粒商城简历.assets\7f8e19548acf4b2eb509145ebec80c8a.png#pic_center)

![](A:\study\学习笔记\谷粒商城简历.assets\50ba37332cf548afa15e99dc2ed22547.png#pic_center)

![](A:\study\学习笔记\谷粒商城简历.assets\6073a7ee0f194c15b4030e755e5bb283.png#pic_center)

### 5.5圈⼦点赞实现分析

在圈⼦功能中，对于圈⼦的点赞、喜欢、评论等均可理解为⽤户对动态的评论（Comment），在quanzi_comment表中使⽤commentType进⾏区分。

在具体的实现中，需要将点赞数、某⽤户是否点赞等数据保存到Reds中，以减轻MongoDB的压⼒。

具体存储结构如下：

![](A:\study\学习笔记\谷粒商城简历.assets\5f37f2b88e2e4602b80d3cc8524598ef.png#pic_center)

> 说明：在Redis的存储结构中，采⽤的是Hash存储，这样的好处就在于⼀条动态的点赞、喜欢等数据都会集中的存储到⼀起，从⽽减少了Redis中数据条数。

六、⼩视频
-----

⼩视频功能类似于抖⾳、快⼿⼩视频的应⽤，⽤户可以上传⼩视频进⾏分享，也可以浏览查看别⼈分享的视频，并且可以对视频评论和点赞操作。

技术⽅案：

*   对于⼩视频的功能的开发，核⼼点就是：存储 \+ 推荐 \+ 加载速度。
    *   对于存储⽽⾔，⼩视频的存储量以及容量都是⾮常巨⼤的。
*   所以我们选择⾃⼰搭建分布式存储系统 FastDFS进⾏存储。
*   对于推荐算法，我们将采⽤多种权重的计算⽅式进⾏计算。
*   对于加载速度，除了提升服务器带宽外可以通过CDN的⽅式进⾏加速，当然了这需要额外购买CDN 服务。

### 6.1 FastDFS⼯作原理

FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进⾏⽂件上传、下载，通过 Tracker server 调度最终由 Storage server 完成⽂件上传和下载。

Tracker server 作⽤是负载均衡和调度，通过 Tracker server 在⽂件上传时可以根据⼀些策略找到

Storage server 提供⽂件上传服务。可以将 tracker 称为追踪服务器或调度服务器。

Storage server 作⽤是⽂件存储，客户端上传的⽂件最终存储在 Storage 服务器上，Storage server 没有实现⾃⼰的⽂件系统⽽是利⽤操作系统的⽂件系统来管理⽂件。可以将storage称为存储服务器。

![](A:\study\学习笔记\谷粒商城简历.assets\22d5d420677b49bc921709d9ad79757e.png#pic_center)

### 6.2文件上传

客户端上传⽂件后存储服务器将⽂件 ID 返回给客户端，此⽂件 ID ⽤于以后访问该⽂件的索引信息。⽂件索引信息包括：组名，虚拟磁盘路径，数据两级⽬录，⽂件名。

![](A:\study\学习笔记\谷粒商城简历.assets\219eb917edce498d87f8011b523abc3c.png#pic_center)

### 6.3文件下载

客户端下载请求到Tracker服务，Tracker返回给客户端storage的信息，客户端根据这些信息进⾏请求storage获取到⽂件。

![](A:\study\学习笔记\谷粒商城简历.assets\2ecf5a14ceb5474ab606fc48e4f499a1.png#pic_center)

### 6.4发布⼩视频

发布⼩视频的流程如下：

![](A:\study\学习笔记\谷粒商城简历.assets\ea73a7dc16ad4c6fa196e4f08f0101b4.png#pic_center)

说明：

*   ⽤户发通过客户端APP上传视频到server服务
*   server服务上传视频到FastDFS⽂件系统，上传成功后返回视频的url地址
*   server通过rpc的调⽤dubbo服务进⾏保存⼩视频数据

七、即时通信
------

在探花交友项⽬中也提供了类似微信的聊天功能，⽤户可以和好友或陌⽣⼈聊天。

如果是陌⽣⼈，通过《聊⼀下》功能进⾏打招呼，如果对⽅同意后，就成为了好友，可以进⾏聊天了。

陌⽣⼈之间如果相互喜欢，那么就会成为好友，也就可以聊天了。

在消息界⾯中也可以查看：点赞、评论、喜欢、公告等消息信息。

**技术⽅案**

对于⾼并发的即时通讯实现，还是很有挑战的，所需要考虑的点⾮常多，除了要实现功能，还要考虑并发、流量、负载、服务器、容灾等等。虽然有难度也并不是⾼不可攀。

对于现实即时通讯往往有两种⽅案：

**⽅案⼀：** 

*   ⾃主实现，从设计到架构，再到实现。
*   技术⽅⾯可以采⽤：Netty + WebSocket + RocketMQ + MongoDB + Redis + ZooKeeper +MySQL
*   ![](A:\study\学习笔记\谷粒商城简历.assets\6a55599bfef6486fa301a882c5531306.png#pic_center)
    

**⽅案⼆：** 

*   对接第三⽅服务完成。
*   这种⽅式简单，只需要按照第三⽅的api进⾏对接就可以了。
*   如：环信、⽹易、容联云通讯等。

**如何选择呢？**

如果是中⼤型企业做项⽬可以选择⾃主研发，如果是中⼩型企业研发中⼩型的项⽬，选择第⼆种⽅案即可。⽅案⼀需要有⼤量的⼈⼒、物⼒的⽀持，开发周期⻓，成本⾼，但可控性强。⽅案⼆，成本低，开发周期短，能够快速的集成起来进⾏功能的开发，只是在可控性⽅⾯来说就差了⼀些。

探花交友项⽬选择⽅案⼆进⾏实现。

**环信** ：官⽹：https://www.easemob.com/稳定健壮，消息必达，亿级并发的即时通讯云

环信平台为⿊⻢学员开设的专⽤注册地址：https://datayi.cn/w/woVL50vR

⽂档地址：http://docs-im.easemob.com/

**整体流程图：** 

说明：

*   在APP端与后端系统，都需要完成与环信的集成。
*   在APP端，使⽤Android的SDK与环信进⾏通信，通信时需要通过后台系统的接⼝查询当前⽤户的环信⽤户名和密码，进⾏登录环信。
*   后台系统，在⽤户注册后，同步注册环信⽤户到环信平台，在后台系统中保存环信的⽤户名和密码。
*   APP拿到⽤户名和密码后，进⾏登录环信，登录成功后即可向环信发送消息给好友。
*   后台系统也可以通过管理员的身份给⽤户发送系统信息。

![](A:\study\学习笔记\谷粒商城简历.assets\ce2c01b8ea234c9598586aa3f94d884a.png#pic_center)

**⽤户系统集成：** 

使⽤环信平台，最重要的就是集成⽤户体系，基本的逻辑是这样的：新⽤户在注册后，同时需要注册环信⽤户。

流程如下：

![](A:\study\学习笔记\谷粒商城简历.assets\a13d3844025642e5842e5f59d4b445f7.png#pic_center)

流程说明：

*   ⽤户在登录时在sso系统中进⾏判断，如果是新⽤户，在注册完成后，需要调⽤dubbo中的环信服务进⾏注册环信⽤户。
*   dubbo-huanxin服务在注册环信⽤户时，需要随机⽣成密码，携带token请求环信的REST API进⾏⽤户注册。
*   注册成功后，需要将环信的⽤户信息保存到MySQL中。
*   ⽤户在APP端使⽤即时通讯功能时，需要通过环信⽤户信息登录到环信平台，由于数据存储到服务端，所以需要通过dubbo-huanxin进⾏查询。
*   在拿到环信账号信息后，登录环信，登录成功后即可与环信平台进⾏交互。
*   需要注意的是，APP端与环信平台交互，是不⾛后端系统的，是直连操作。

**添加联系⼈：** 

点击“聊⼀下”，就会成为联系⼈（好友）。

实现：

*   将好友写⼊到MongoDB中
*   将好友关系注册到环信

具体的流程如下：

![](A:\study\学习笔记\谷粒商城简历.assets\0a3e3b8ccd8c4cd5907b658b63749876.png#pic_center)

**聊⼀下：** 

在个⼈主⻚中，点击聊⼀下按钮，会弹出回答问题窗⼝，输⼊答案后，系统会向对⽅发送⼀条陌聊消息，如果对⽅在陌聊消息中点击聊⼀下，他们就会成为好友。

⽤户1在⽤户2的个⼈主⻚中点击“聊⼀下”，流程如下：

![](A:\study\学习笔记\谷粒商城简历.assets\12109eb028c649aa86a58660431e0320.png#pic_center)

八、附近的人
------

1、上报地理位置

当客户端检测⽤户的地理位置，当变化⼤于500⽶时或每隔5分钟，向服务端上报地理位置。

⽤户的地理位置存储到Elasticsearch中，需要使⽤环境提供的ES集群，如下：

![](A:\study\学习笔记\谷粒商城简历.assets\f28fd06f678446ab80e65d14ac1340d4.png#pic_center)

九、推荐功能
------

**9.1 什么是推荐系统**

**为了解决信息过载和⽤户⽆明确需求的问题，找到⽤户感兴趣的物品，才有了个性化推荐系统。** 

其实，解决信息过载的问题，代表性的解决⽅案是分类⽬录和搜索引擎，如hao123，电商⾸⻚的分类⽬录以及百度，360搜索等。

不过分类⽬录和搜索引擎只能解决⽤户主动查找信息的需求，即⽤户知道⾃⼰想要什么，并不能解决⽤户没⽤明确需求很随便的问题。

经典语录是：你想吃什么，随便！⾯对这种很随便⼜得罪不起的⽤户（⼥友和上帝），只能**通过分析⽤户的历史⾏为给⽤户的兴趣建模**，从⽽主动给⽤户推荐能够满⾜他们兴趣和需求的信息。⽐如问问⼥友的闺蜜，她⼀般什么时候喜欢吃什么。

**9.2 推荐系统业务流程：** 

![](A:\study\学习笔记\谷粒商城简历.assets\7d53b71087b844ccb79562d26865a50e.png#pic_center)

推荐系统⼴泛存在于各类⽹站中，作为⼀个应⽤为⽤户提供个性化的推荐。它需要⼀些⽤户的历史数据，⼀般由三个部分组成：基础数据、推荐算法系统、前台展示。

*   基础数据包括很多维度，包括⽤户的访问、浏览、下单、收藏，⽤户的历史订单信息，评价信息等很多信息；
*   推荐算法系统主要是根据不同的推荐诉求由多个算法组成的推荐模型；
*   前台展示主要是对客户端系统进⾏响应，返回相关的推荐信息以供展示。

**9.3 协同过滤推荐算法**

迄今为⽌，在个性化推荐系统中，协同过滤技术是应⽤最成功的技术。⽬前国内外有许多⼤型⽹站应⽤这项技术为⽤户更加智能（个性化、千⼈千⾯）的推荐内容。

> 核⼼思想：协同过滤⼀般是在海量的⽤户中发掘出⼀⼩部分和你品位⽐较类似的，在协同过滤中，这些⽤户成为邻居，然后根据他们喜欢的其他东⻄组织成⼀个排序的⽬彔作为推荐给你。

**9.3.1 基于⽤户的推荐 UserCF**

![](A:\study\学习笔记\谷粒商城简历.assets\46f942abdd994b849048274c6ace2b40.png#pic_center)

![](A:\study\学习笔记\谷粒商城简历.assets\5dbe9378a9d2418fb4448be5c182c802.png#pic_center)

对于⽤户A，根据⽤户的历史偏好，这⾥只计算得到⼀个邻居–⽤户C，然后将⽤户C 喜欢的物品D 推荐给⽤户A。

基于⽤户的协同过滤算法先计算的是⽤户与⽤户的相似度（兴趣相投，物以类聚⼈以群分），然后将相似度⽐较接近的⽤户A购买的物品推荐给⽤户B，专业的说法是该算法⽤最近邻居（nearest-neighbor）算法找出⼀个⽤户的邻居集合，该集合的⽤户和该⽤户有相似的喜好，算法根据邻居的偏好对该⽤户进⾏预测。

**9.3.2、基于商品的推荐 ItemCF**

![](A:\study\学习笔记\谷粒商城简历.assets\dfa2be0db02b44e1a84745506f9c95da.png#pic_center)

*   基于ItemCF的原理和基于UserCF类似，只是在计算邻居时采⽤物品本身，⽽不是从⽤户的⻆度，即基于⽤户对物品的偏好找到相似的物品，然后根据⽤户的历史偏好，推荐相似的物品给他。
*   从计算的⻆度看，就是将所有⽤户对某个物品的偏好作为⼀个向量来计算物品之间的相似度，得到物品的相似物品后，根据⽤户历史的偏好预测当前⽤户还没有表示偏好的物品，计算得到⼀个排序的物品列表作为推荐。
*   解释：对于物品A，根据所有⽤户的历史偏好，喜欢物品A 的⽤户都喜欢物品C，得出物品A 和物品C ⽐较相似，⽽⽤户C 喜欢物品A，那么可以推断出⽤户C 可能也喜欢物品C。

### **9.4 好友推荐**

对于好友的推荐，需要找出每个⽤户之间的相似性，具体规则如下：

![](A:\study\学习笔记\谷粒商城简历.assets\04f309d66aea42f8ae286d8807e26cc9.png#pic_center)

**流程:**

![](A:\study\学习笔记\谷粒商城简历.assets\1ba19809b0d14ed8bd9bb80d7f60ce91.png#pic_center)

### 9.4、圈⼦推荐

**功能说明:** 在圈⼦功能中，针对于⽤户发布的动态信息，系统可以根据⽤户的发布、浏览、点赞等操作，对动态信息做计算，然后对每个⽤户进⾏不同的推荐。

**流程说明:**

![](A:\study\学习笔记\谷粒商城简历.assets\4fc1060ec37245f89affcceecb11f640.png#pic_center)

流程说明：

*   ⽤户对圈⼦的动态操作，如：发布、浏览、点赞、喜欢等，就会给RocketMQ进⾏发送消息；
*   推荐系统接收消息，并且处理消息数据，处理之后将结果数据写⼊到MongoDB中；
*   Spark系统拉取数据，然后进⾏推荐计算；
*   计算之后的结果数据写⼊到Redis中，为每个⽤户都进⾏个性化推荐；

**动态计分规则**

*   浏览 +1
    
*   点赞 +5
    
*   喜欢 +8
    
*   评论 \+ 10
    
*   发布动态
    
    *   ⽂字⻓度：50以内1分，50~100之间2分，100以上3分
        
    *   图⽚个数：每个图⽚⼀分
        

**核⼼推荐逻辑：** 

*   推荐模型：⽤户 | 动态| 评分
*   其中，评分是⽤户对动态操作的得分合计
*   为什么⾃⼰发布动态还要计分？是因为，⾃⼰发布就相当于⾃⼰对此动态也感兴趣，这样就可以在相似的⼈之间进⾏推荐了。

# 商城面试题

******1.网站并发数：******

经过[压力测试](https://so.csdn.net/so/search?q=%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95&spm=1001.2101.3001.7020)可以支持3000左右的并发，可以满足目前的业务需求。由于我们的系统是分布式架构，支持水平扩展，如果将来并发量提高的话，可以增加服务器来提高并发量。

******2.人员配置******

产品经理：3人，确定需求以及给出产品原型图。

项目经理：1人，项目管理。

前端团队：5人，根据产品经理给出的原型制作静态页面。

后端团队：20人，实现产品功能。

测试团队：5人，测试所有的功能。

运维团队：3人，项目的发布以及维护。

******3.开发周期******

采用迭代开发的方式进行，一般一次迭代的周期为一个月左右。

******4.Sku/spu******

最小库存量单位。

Sku==商品id

******5.你说你用了redis缓存，你redis存的是什么格式的数据，是怎么存的******

redis中存储的都是key-value格式的。拿商品数据来说，key就是商品id，value是商品相关信息的json数据。

******6.你前台portal采用4台服务器集群部署，那能前台高并发访问性能提上去了，那数据库会不会造成一个瓶颈，这一块你是怎么处理的？******

portal系统在高并发的情况下如果每次请求都请求都查询数据库确实会出现数据库的瓶颈。为了降低数据库压力，在服务层会添加一个缓存，用redis实现，这样的话请求先到缓存中查找是否有缓存的内容，如果有直接从缓存中取数据，如果没有再到数据库中查询。这样数据库的压力就不会那么大了。

******7.你购物车存cookie里边 可以实现不登录就可以使用购物车 那么我现在没有登录把商品存购物车了 然后登录了 然后我换台电脑并且登录了还能不能看见我购物车的信息？如果看不到怎么做到cookie同步，就是在另外一台电脑上可以看到购物车信息******

淘淘商城现阶段使用的仅仅是把购物车的商品写入cookie中，这样服务端基本上么有存储的压力。但是弊端就是用户更换电脑后购物车不能同步。打算下一步这么实现：当用户没有登录时向购物车添加商品是添加到cookie中，当用户登录后购物车的信息是存储在redis中的并且是跟用户id向关联的，此时你更换电脑后使用同一账号登录购物车的信息就会展示出来。

******8.如果用户一直添加购物车添加商品怎么办？并且他添加一次你查询一次数据库？互联网上用户那么多，这样会对数据库造成很大压力你怎么办？******

当前我们使用cookie的方式来保存购物车的数据，所以当用户往购物车中添加商品时，并不对数据库进行操作。将来把购物车商品放入redis中，redis是可以持久化的可以永久保存，此时就算是频繁的往购物车中添加数据也没用什么问题。

******9.电商活动倒计时方案******

1.  确定一个基准时间。可以使用一个sql语句从数据库中取出一个当前时间。SELECT NOW()；
2.  活动开始的时间是固定的。
3.  使用活动开始时间-基准时间可以计算出一个秒为单位的数值。
4.  在redis中设置一个key（活动开始标识）。设置key的过期时间为第三步计算出来的时间。
5.  展示页面的时候取出key的有效时间。Ttl命令。使用js倒计时。
6.  一旦活动开始的key失效，说明活动开始。
7.  需要在活动的逻辑中，先判断活动是否开始。

******10.秒杀抢购库存解决方案******

1.  把商品的数量放到redis中。
2.  秒杀时使用decr命令对商品数量减一。如果不是负数说明抢到。
3.  一旦返回数值变为0说明商品已售完。

******11.dubbo服务开发流程，运行流程？zookeeper注册中心的作用？******

使用流程：

第一步：要在系统中使用dubbo应该先搭建一个注册中心，一般推荐使用zookeeper。

第二步：有了注册中心然后是发布服务，发布服务需要使用spring容器和dubbo标签来发布服务。并且发布服务时需要指定注册中心的位置。

第三步：服务发布之后就是调用服务。一般调用服务也是使用spring容器和dubbo标签来引用服务，这样就可以在客户端的容器中生成一个服务的代理对象，在action或者Controller中直接调用service的方法即可。

Zookeeper注册中心的作用主要就是注册和发现服务的作用。类似于房产中介的作用，在系统中并不参与服务的调用及数据的传输。

******12.redis为什么可以做缓存？项目中使用redis的目的是什么？redis什么时候使用？******

      1.Redis是key-value形式的nosql数据库。可以快速的定位到所查找的key，并把其中的value取出来。并且redis的所有的数据都是放到内存中，存取的速度非常快，一般都是用来做缓存使用。
    
      2.项目中使用redis一般都是作为缓存来使用的，缓存的目的就是为了减轻数据库的压力提高存取的效率。
    
      3.在互联网项目中只要是涉及高并发或者是存在大量读数据的情况下都可以使用redis作为缓存。当然redis提供丰富的数据类型，除了缓存还可以根据实际的业务场景来决定redis的作用。例如使用redis保存用户的购物车信息、生成订单号、访问量计数器、任务队列、排行榜等。

******13.acitveMQ的作用、原理？（生产者。消费者。 p2p、订阅实现流程）******

Activemq的作用就是系统之间进行通信。当然可以使用其他方式进行系统间通信，如果使用Activemq的话可以对系统之间的调用进行解耦，实现系统间的异步通信。原理就是生产者生产消息，把消息发送给activemq。Activemq接收到消息，然后查看有多少个消费者，然后把消息转发给消费者，此过程中生产者无需参与。消费者接收到消息后做相应的处理和生产者没有任何关系。

******14.activeMQ在项目中如何应用的？******

Activemq在项目中主要是完成系统之间通信，并且将系统之间的调用进行解耦。例如在添加、修改商品信息后，需要将商品信息同步到索引库、同步缓存中的数据以及生成静态页面一系列操作。在此场景下就可以使用activemq。一旦后台对商品信息进行修改后，就向activemq发送一条消息，然后通过activemq将消息发送给消息的消费端，消费端接收到消息可以进行相应的业务处理。

******15.activeMQ如果数据提交不成功怎么办？******

Activemq有两种通信方式，点到点形式和发布订阅模式。如果是点到点模式的话，如果消息发送不成功此消息默认会保存到activemq服务端知道有消费者将其消费，所以此时消息是不会丢失的。

如果是发布订阅模式的通信方式，默认情况下只通知一次，如果接收不到此消息就没有了。这种场景只适用于对消息送达率要求不高的情况。如果要求消息必须送达不可以丢失的话，需要配置持久订阅。每个订阅端定义一个id，在订阅是向activemq注册。发布消息和接收消息时需要配置发送模式为持久化。此时如果客户端接收不到消息，消息会持久化到服务端，直到客户端正常接收后为止。

******16.当被问到某个模快存在安全性问题（sso单点登录系统）时，如何回答？******

目前商城的sso系统的解决方案中直接把token保存到cookie中，确实存在安全性问题。但是实现简单方便。如果想提高安全性可以使用cas框架实现单点登录。

[https://www.apereo.org/projects/cas](https://www.apereo.org/projects/cas)

******17.当技术面试官问到你某个技术点更深层次研究时，自己没有深入了解怎么********回答********？******

如果没有深入研究就直接回答不知道就可以了。

******18.solr怎么设置搜索结果排名靠前（得分）？******

可以设置文档中域的boost值，boost值越高计算出来的相关度得分就越高，排名也就越靠前。此方法可以把热点商品或者是推广商品的排名提高。

******19.solr的原理******

Solr是基于Lucene开发的全文检索服务器，而Lucene就是一套实现了全文检索的api，其本质就是一个全文检索的过程。全文检索就是把原始文档根据一定的规则拆分成若干个关键词，然后根据关键词创建索引，当查询时先查询索引找到对应的关键词，并根据关键词找到对应的文档，也就是查询结果，最终把查询结果展示给用户的过程。

******20.solr里面IK分词器的原理******

IK分析器的分词原理本质上是词典分词。现在内存中初始化一个词典，然后在分词过程中逐个读取字符，和字典中的字符相匹配，把文档中的所有的词语拆分出来的过程。

******21.支付接口是怎么做的？******

面试中可以说支付这部分不是我们做的，我们项目中并没有涉及支付部分的处理。如果想了解支付是如何实现可以参考之前学过的易宝支付相关处理以及支付宝、微信支付相关文档。

支付宝：

[https://doc.open.alipay.com/doc2/apiDetail.htm?spm=a219a.7629065.0.0.eeTXH8&apiId=850&docType=4#](https://doc.open.alipay.com/doc2/apiDetail.htm?spm=a219a.7629065.0.0.eeTXH8&apiId=850&docType=4#)

微信支付：

[https://mp.weixin.qq.com/cgi-bin/readtemplate?t=business/faq_tmpl](https://mp.weixin.qq.com/cgi-bin/readtemplate?t=business/faq_tmpl)

******22.业务如何说？先说业务、说表、说具体实现？******

先说总体的业务流程，然后再说具体业务的实现方法及使用的技术。最后说你在系统中负责的内容。不需要说表结构。

******23.单点登录系统，如果cookie禁用，你们怎么解决?******

如果禁用cookie可以使用url中带参数，把token传递给服务端。当然此方法涉及安全性问题，其实在cookie中保存token同样存在安全性问题。推荐使用sso框架CAS实现单点登录。

******24.你们做移动端没有，如果没有移动端，你们为什么做单点登录？******

单点登录并不是为移动端准备的，移动端有自己的登录方式。单点登录是解决在同一个公司内部多个互信网站之间进行跳转时不需要多次登录，多个系统统一登录入口。

******25.单点登录的核心是什么？******

单点登录的核心是如何在多个系统之间共享身份信息。

******26.除了单点登陆，还做过什么登陆的方式？******

这是什么狗屁问题？除了单点登录那就是普通登录方式，用户在同一个公司的多个系统之间跳转时需要多次登录。

******27.单点登录，http无状态的，别人模仿如何在后端处理******

http是无状态的，如果别人模仿浏览器发送http请求，一般后台是无法识别的。如果对安全要求高的情况下应该是https协议。可以保证在通信过程中无法窃取通信内容。

******28.安全性问题（别的网站使用爬虫技术爬你的网站怎么办？有没有安全措施）******

单位时间内请求次数超过某个阈值就让输入验证码，可以极大降低抓取的速度，如果多次超过某个阀值可以加入黑名单。还有就是页面内容使用json返回，数据经常变一变格式，或者js动态生成页面内容。

******29.商品存入数据库怎么保证数据库数据安全?******

      1.对用户安全管理

用户操作数据库时，必须通过数据库访问的身份认证。删除数据库中的默认用户，使用自定义的用户及高强度密码。

      2.定义视图

为不同的用户定义不同的视图，可以限制用户的访问范围。通过视图机制把需要保密的数据对无权存取这些数据的用户隐藏起来，可以对数据库提供一定程度的安全保护。实际应用中常将视图机制与授权机制结合起来使用，首先用视图机制屏蔽一部分保密数据，然后在视图上进一步进行授权。

      3.数据加密

数据加密是保护数据在存储和传递过程中不被窃取或修改的有效手段。

      4.数据库定期备份

5)审计追踪机制

审计追踪机制是指系统设置相应的日志记录，特别是对数据更新、删除、修改的记录，以便日后查证。日志记录的内容可以包括操作人员的名称、使用的密码、用户的IP地址、登录时间、操作内容等。若发现系统的数据遭到破坏，可以根据日志记录追究责任，或者从日志记录中判断密码是否被盗，以便修改密码，重新分配权限，确保系统的安全。

******30.订单表的数据量太大,我把订单分到许多表中,那么我我想用一条sql查处所有的订单,怎么解决?******

分库情况下：可以使用mycat数据库中间件实现多个表的统一管理。虽然物理上是把一个表中的数据保存到多个数据库中，但是逻辑上还是一个表，使用一条sql语句就可以把数据全部查询出来。

单库情况下：需要动态生成sql语句。先查询订单相关的表，然后将查询多个表的sql语句使用union连接即可。

******31.咱们单点登录模块中，别人伪造我们cookie中的token怎么办？******

服务端是无法阻止伪造cookie的，如果对安全性要求高的话可以可使用cas框架。

******32.第一个是当两个客户同时买一件商品时库存只有一个了,怎么控制?******

可以使用mysql的行锁机制，实现乐观锁，在更新商品之前将商品锁定，其他用户无法读取，当此用户操作完毕后释放锁。当并发量高的情况下，需要使用缓存工具例如redis来管理库存。

******33.对数据库只是采用了读写分离,并没有完全解决数据库的压力,那么有什么办法解决?******

如果数据库压力确实很大的情况下可以考虑数据库分片，就是将数据库中表拆分到不同的数据库中保存。可以使用mycat中间件。

******34.同一账号以客户端登录怎么挤掉另一端。******

用户登录后需要在Session中保存用户的id。当用户登录时，从当前所有的Session中判断是否有此用户id的存在，如果存在的话就把保存此用户id的Session销毁。

******35.solr的索引查询为什么比数据库要快。******

Solr使用的是Lucene API实现的全文检索。全文检索本质上是查询的索引。而数据库中并不是所有的字段都建立的索引，更何况如果使用like查询时很大的可能是不使用索引，所以使用solr查询时要比查数据库快。

******36.solr索引库个别数据索引丢失怎么办。******

首先Solr是不会丢失个别数据的。如果索引库中缺少数据，那就向索引库中添加。（靠！什么狗屁问题！！！）

******37.Lucene索引优化。******

直接使用Lucene实现全文检索已经是过时的方案，推荐使用solr。Solr已经提供了完整的全文检索解决方案。